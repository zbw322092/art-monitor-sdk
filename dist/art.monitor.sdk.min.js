(function () {
  'use strict';

  const RANDOM = Math.random().toString(36).substr(2, 9) + '_' + Date.now();
  //# sourceMappingURL=RANDOM.js.map

  window.TRACKID = RANDOM;
  //# sourceMappingURL=TRACKID.js.map

  // import './xhrInterceptor.ts';
  //# sourceMappingURL=index.js.map

  // import './Event/network';
  // import './Event/scroll';
  // import './Event/resize';
  // import './UIEvent/select';
  // import './MouseEvent/mouseEvent';
  // import './KeyboardEvent/keyboardEvent';
  // import './TouchEvent/touchEvent';
  // import './FocusEvent/focusEvent';
  // import './PointerEvent/pointerEvent';
  // import './CustomEvent/statechangeEvent';
  //# sourceMappingURL=index.js.map

  // import { Cursor } from './Cursor';
  const promisifyRequest = (request) => {
      return new Promise((resolve, reject) => {
          request.onsuccess = () => {
              resolve(request.result);
          };
          request.onerror = () => {
              reject(request.error);
          };
      });
  };
  const promisifyRequestCall = (obj, method, args) => {
      let request;
      const promiseCall = new Promise((resolve, reject) => {
          request = obj[method].apply(obj, args);
          if (request) {
              promisifyRequest(request).then(resolve, reject);
          }
      });
      promiseCall.request = request;
      return promiseCall;
  };
  const promisifyCursorRequestCall = (obj, method, args, Cursor) => {
      const promiseCall = promisifyRequestCall(obj, method, args);
      return promiseCall.then((value) => {
          if (!value) {
              return;
          }
          return new Cursor(value, promiseCall.request);
      });
  };
  //# sourceMappingURL=promisifyRequest.js.map

  const proxyProperties = (ProxyClass, targetProp, properties) => {
      properties.forEach((prop) => {
          Object.defineProperty(ProxyClass.prototype, prop, {
              get() {
                  return this[targetProp][prop];
              },
              set(val) {
                  return this[targetProp][prop] = val;
              }
          });
      });
  };
  const proxyRequestMethods = (ProxyClass, targetProp, Constructor, properties) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return promisifyRequestCall(this[targetProp], prop, arguments);
          };
      });
  };
  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return this[targetProp][prop].apply(this[targetProp], arguments);
          };
      });
  }
  const proxyCursorRequestMethods = (ProxyClass, targetProp, Constructor, properties, Cursor) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype))
              return;
          ProxyClass.prototype[prop] = function () {
              return promisifyCursorRequestCall(this[targetProp], prop, arguments, Cursor);
          };
      });
  };
  //# sourceMappingURL=proxies.js.map

  function Cursor(cursor, request) {
      this._cursor = cursor;
      this._request = request;
  }
  proxyProperties(Cursor, '_cursor', [
      'direction',
      'key',
      'primaryKey',
      'value'
  ]);
  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
      'update',
      'delete'
  ]);
  //# sourceMappingURL=Cursor.js.map

  function Index(index) {
      this._index = index;
  }
  proxyProperties(Index, '_index', [
      'name',
      'keyPath',
      'multiEntry',
      'unique'
  ]);
  proxyRequestMethods(Index, '_index', IDBIndex, [
      'get',
      'getKey',
      'getAll',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  //# sourceMappingURL=DBIndex.js.map

  function ObjectStore(store) {
      this._store = store;
  }
  ObjectStore.prototype.createIndex = function () {
      return new Index(this._store.createIndex.apply(this._store, arguments));
  };
  ObjectStore.prototype.index = function () {
      return new Index(this._store.index.apply(this._store, arguments));
  };
  proxyProperties(ObjectStore, '_store', [
      'name',
      'keyPath',
      'indexNames',
      'autoIncrement'
  ]);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'put',
      'add',
      'delete',
      'clear',
      'get',
      'getAll',
      'getKey',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'deleteIndex'
  ]);
  //# sourceMappingURL=ObjectStore.js.map

  function Transaction(idbTransaction) {
      this._tx = idbTransaction;
      this.complete = new Promise((resolve, reject) => {
          idbTransaction.oncomplete = () => {
              resolve();
          };
          idbTransaction.onerror = () => {
              reject(idbTransaction.error);
          };
          idbTransaction.onabort = () => {
              reject(idbTransaction.error);
          };
      });
  }
  Transaction.prototype.objectStore = function () {
      return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };
  proxyProperties(Transaction, '_tx', [
      'objectStoreNames',
      'mode'
  ]);
  proxyMethods(Transaction, '_tx', IDBTransaction, [
      'abort'
  ]);
  //# sourceMappingURL=Transaction.js.map

  function UpgradeDB(db, oldVersion, transaction) {
      this._db = db;
      this.oldVersion = oldVersion;
      this.transaction = transaction ? new Transaction(transaction) : null;
  }
  UpgradeDB.prototype.createObjectStore = function () {
      return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };
  proxyProperties(UpgradeDB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
      'deleteObjectStore',
      'close'
  ]);
  //# sourceMappingURL=UpgradeDB.js.map

  function DB(db) {
      this._db = db;
  }
  proxyProperties(DB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(DB, '_db', IDBDatabase, [
      'close'
  ]);
  DB.prototype.transaction = function () {
      return new Transaction(this._db.transaction.apply(this._db, arguments));
  };
  //# sourceMappingURL=db.js.map

  function toArray(arr) {
      return Array.prototype.slice.call(arr);
  }
  ['advance', 'continue', 'continuePrimaryKey'].forEach((methodName) => {
      if (!(methodName in IDBCursor.prototype)) {
          return;
      }
      Cursor.prototype[methodName] = function () {
          const cursor = this;
          const args = arguments;
          return Promise.resolve().then(() => {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then((value) => {
                  if (!value) {
                      return;
                  }
                  return new Cursor(value, cursor._request);
              });
          });
      };
  });
  // Add cursor iterators
  ['openCursor', 'openKeyCursor'].forEach((funcName) => {
      [ObjectStore, Index].forEach((Constructor) => {
          // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
          if (!(funcName in Constructor.prototype)) {
              return;
          }
          Constructor.prototype[funcName.replace('open', 'iterate')] = function () {
              const args = toArray(arguments);
              const callback = args[args.length - 1];
              const nativeObject = this._store || this._index;
              const request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
              request.onsuccess = () => {
                  callback(request.result);
              };
          };
      });
  });
  // polyfill getAll
  [Index, ObjectStore].forEach((Constructor) => {
      if (Constructor.prototype.getAll)
          return;
      Constructor.prototype.getAll = function (query, count) {
          const instance = this;
          const items = [];
          return new Promise((resolve) => {
              instance.iterateCursor(query, (cursor) => {
                  if (!cursor) {
                      resolve(items);
                      return;
                  }
                  items.push(cursor.value);
                  if (count !== undefined && items.length === count) {
                      resolve(items);
                      return;
                  }
                  cursor.continue();
              });
          });
      };
  });
  const idb = {
      open: (name, version, upgradeCallback) => {
          const promiseWithReq = promisifyRequestCall(indexedDB, 'open', [name, version]);
          const request = promiseWithReq.request;
          if (request) {
              request.onupgradeneeded = (event) => {
                  if (upgradeCallback) {
                      upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
                  }
              };
          }
          return promiseWithReq.then((db) => {
              return new DB(db);
          });
      },
      delete: (name) => {
          return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
      }
  };
  //# sourceMappingURL=idb.js.map

  //# sourceMappingURL=index.js.map

  const DBNAME = 'QNN-MKT';
  const DBVERSION = 1;
  const OBJECTNAME = 'ERROR-REPORTING';
  const KETPATH = 'id';
  const CLEARINTERVAL = 15000;
  const CLEARRANGELOW = 20000;
  const CLEARRANGEHIGH = 10000;
  const OFFSET = 20;
  //# sourceMappingURL=DB.js.map

  class IDBStore {
      constructor(dbName, upgradeCallback) {
          this.get = (objName, key) => {
              return this.dbPromise.then((db) => {
                  return db.transaction(objName)
                      .objectStore(objName).get(key);
              });
          };
          this.set = (objName, val) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).put(val);
                  return tx.complete;
              });
          };
          this.delete = (objName, key) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).delete(key);
                  return tx.complete;
              });
          };
          this.clear = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).clear();
                  return tx.complete;
              });
          };
          this.getDBPromise = () => {
              return this.dbPromise;
          };
          this.keys = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName);
                  const keys = [];
                  const store = tx.objectStore(objName);
                  // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.
                  // openKeyCursor isn't supported by Safari, so we fall back
                  (store.iterateKeyCursor || store.iterateCursor).call(store, (cursor) => {
                      if (!cursor) {
                          return;
                      }
                      keys.push(cursor.key);
                      cursor.continue();
                  });
                  return tx.complete.then(() => {
                      return keys;
                  });
              });
          };
          this.dbPromise = idb.open(dbName, DBVERSION, upgradeCallback);
      }
      deleteDataBase(dbName) {
          return idb.delete(dbName)
              .then(() => {
              console.log(`delete ${dbName} database successfully`);
          })
              .catch((err) => {
              console.log(`delete ${dbName} database err: `, err);
          });
      }
  }
  const iDBStoreInstance = new IDBStore(DBNAME, (upgradeDB) => {
      if (!upgradeDB.objectStoreNames.contains(OBJECTNAME)) {
          const objectStore = upgradeDB.createObjectStore(OBJECTNAME, { keyPath: KETPATH, autoIncrement: true });
          objectStore.createIndex('timestamp', 'timestamp');
      }
  });
  //# sourceMappingURL=IDBStore.js.map

  window.setInterval(() => {
      const now = performance.now();
      const range = IDBKeyRange.bound(now - CLEARRANGELOW - OFFSET, now - CLEARRANGEHIGH + OFFSET);
      let count = 0;
      let minIndex, maxIndex;
      iDBStoreInstance.getDBPromise()
          .then((db) => {
          const transaction = db.transaction(OBJECTNAME);
          const store = transaction.objectStore(OBJECTNAME);
          const index = store.index('timestamp');
          return index.openCursor(range);
      }).then(function showRange(cursor) {
          if (!cursor) {
              return;
          }
          const primaryKey = cursor.primaryKey;
          if (minIndex === undefined) {
              minIndex = primaryKey;
          }
          if (maxIndex === undefined) {
              maxIndex = primaryKey;
          }
          minIndex = primaryKey < minIndex ? primaryKey : minIndex;
          maxIndex = primaryKey > maxIndex ? primaryKey : maxIndex;
          count++;
          return cursor.continue().then(showRange);
      }).then(function () {
          if (minIndex === maxIndex) {
              console.log('no new records');
              return;
          }
          iDBStoreInstance.delete(OBJECTNAME, IDBKeyRange.bound(minIndex, maxIndex))
              .then(() => {
              console.log(`${count} records deleted`);
          })
              .catch((err) => {
              console.log(`delete record has err: `, err);
          });
      });
  }, CLEARINTERVAL);
  //# sourceMappingURL=intervalClear.js.map

  const getBehaviorRecords = () => {
      const now = performance.now();
      const range = IDBKeyRange.bound(now - CLEARINTERVAL, now);
      let count = 0;
      let minIndex, maxIndex;
      let store;
      return iDBStoreInstance.getDBPromise()
          .then((db) => {
          const transaction = db.transaction(OBJECTNAME);
          store = transaction.objectStore(OBJECTNAME);
          const index = store.index('timestamp');
          return index.openCursor(range);
      }).then(function showRange(cursor) {
          if (!cursor) {
              return;
          }
          const primaryKey = cursor.primaryKey;
          if (minIndex === undefined) {
              minIndex = primaryKey;
          }
          if (maxIndex === undefined) {
              maxIndex = primaryKey;
          }
          minIndex = primaryKey < minIndex ? primaryKey : minIndex;
          maxIndex = primaryKey > maxIndex ? primaryKey : maxIndex;
          count++;
          return cursor.continue().then(showRange);
      }).then(function () {
          if (minIndex === maxIndex) {
              console.log('no new records');
              return;
          }
          return store.getAll(IDBKeyRange.bound(minIndex, maxIndex))
              .then((records) => {
              console.log(`got ${count} records`);
              return records;
          })
              .catch((err) => {
              return err;
          });
      });
  };
  //# sourceMappingURL=getBehaviorRecords.js.map

  class LoggerBase {
      constructor(TrackType) {
          this.timestamp = performance.now();
          this.trackId = window.TRACKID;
          this.TrackType = TrackType;
      }
  }
  //# sourceMappingURL=LoggerBase.js.map

  const nodeMirror = {
      map: {},
      getId(node) {
          // if node has not been serialized, return -1
          if (!node.__sn) {
              return -1;
          }
          return node.__sn.id;
      },
      getNode(id) {
          return nodeMirror.map[id] || null;
      },
      removeNodeFromMap(node) {
          const id = node.__sn && node.__sn.id;
          delete nodeMirror.map[id];
          if (node.childNodes) {
              node.childNodes.forEach((child) => {
                  nodeMirror.removeNodeFromMap(child);
              });
          }
      },
      has(id) {
          return nodeMirror.map.hasOwnProperty(id);
      }
  };
  //# sourceMappingURL=nodeMirror.js.map

  class LoggerEvent extends LoggerBase {
      constructor(TrackType, event) {
          super(TrackType);
          this.type = event.type;
          this.eventPhase = event.eventPhase;
          // this.currentTarget = getEventTargetInfo(event.currentTarget);
          // this.target = getEventTargetInfo(event.target);
          // console.log('event.currentTarget: ', event.currentTarget);
          // console.log('event.target: ', event.target);
          this.currentTarget = event.currentTarget ? nodeMirror.getId(event.currentTarget) : null;
          this.target = event.target ? nodeMirror.getId(event.target) : null;
      }
  }
  //# sourceMappingURL=LoggerEvent.js.map

  class LoggerError extends LoggerEvent {
      constructor(TrackType, errorEvent) {
          super(TrackType, errorEvent);
          this.message = errorEvent.message;
          this.filename = errorEvent.filename;
          this.lineno = errorEvent.lineno;
          this.colno = errorEvent.colno;
          this.error = JSON.stringify(errorEvent.error);
      }
  }
  //# sourceMappingURL=LoggerError.js.map

  var TrackType;
  (function (TrackType) {
      TrackType[TrackType["EVENT_NETWORKEVENT"] = 0] = "EVENT_NETWORKEVENT";
      TrackType[TrackType["EVENT_SCROLL"] = 1] = "EVENT_SCROLL";
      TrackType[TrackType["EVENT_RESIZE"] = 2] = "EVENT_RESIZE";
      TrackType[TrackType["UIEVENT_SELECT"] = 3] = "UIEVENT_SELECT";
      TrackType[TrackType["KEYBOARDEVENT_KEYDOWN"] = 4] = "KEYBOARDEVENT_KEYDOWN";
      TrackType[TrackType["MOUSEEVENT_CLICK"] = 5] = "MOUSEEVENT_CLICK";
      TrackType[TrackType["TOUCHEVENT_TOUCHSTART"] = 6] = "TOUCHEVENT_TOUCHSTART";
      TrackType[TrackType["TOUCHEVENT_TOUCHMOVE"] = 7] = "TOUCHEVENT_TOUCHMOVE";
      TrackType[TrackType["TOUCHEVENT_TOUCHEND"] = 8] = "TOUCHEVENT_TOUCHEND";
      TrackType[TrackType["TOUCHEVENT_TOUCHCANCEL"] = 9] = "TOUCHEVENT_TOUCHCANCEL";
      TrackType[TrackType["FOCUSEVENT_FOCUSIN"] = 10] = "FOCUSEVENT_FOCUSIN";
      TrackType[TrackType["FOCUSEVENT_FOCUSOUT"] = 11] = "FOCUSEVENT_FOCUSOUT";
      TrackType[TrackType["POINTEREVENT_POINTERMOVE"] = 12] = "POINTEREVENT_POINTERMOVE";
      TrackType[TrackType["STATECHANGE"] = 13] = "STATECHANGE";
      TrackType[TrackType["MUTATION"] = 14] = "MUTATION";
      TrackType[TrackType["XHRINTERCEPT"] = 15] = "XHRINTERCEPT";
      TrackType[TrackType["ERROR"] = 16] = "ERROR";
      TrackType[TrackType["EVENT_SELECTIONSTART"] = 17] = "EVENT_SELECTIONSTART";
      TrackType[TrackType["EVENT_SELECTIONCHANGE"] = 18] = "EVENT_SELECTIONCHANGE";
      TrackType[TrackType["INPUTEVENT_INPUT"] = 19] = "INPUTEVENT_INPUT";
  })(TrackType || (TrackType = {}));
  //# sourceMappingURL=TrackType.js.map

  var HttpMethod;
  (function (HttpMethod) {
      HttpMethod["GET"] = "GET";
      HttpMethod["POST"] = "POST";
      HttpMethod["PUT"] = "PUT";
      HttpMethod["DELETE"] = "DELETE";
      HttpMethod["HEAD"] = "HEAD";
      HttpMethod["OPTIONS"] = "OPTIONS";
  })(HttpMethod || (HttpMethod = {}));
  //# sourceMappingURL=HttpMethod.js.map

  var ReadyState;
  (function (ReadyState) {
      ReadyState[ReadyState["UNSENT"] = 0] = "UNSENT";
      ReadyState[ReadyState["OPENED"] = 1] = "OPENED";
      ReadyState[ReadyState["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
      ReadyState[ReadyState["LOADING"] = 3] = "LOADING";
      ReadyState[ReadyState["DONE"] = 4] = "DONE";
  })(ReadyState || (ReadyState = {}));
  //# sourceMappingURL=ReadyState.js.map

  function XHR(url, options, callback) {
      let xhr = options.xhr || null;
      const nativeXMLHttpRequest = XMLHttpRequest || noop;
      const nativeXDomainRequest = 'withCredentials' in (new nativeXMLHttpRequest()) ?
          XMLHttpRequest : window.XDomainRequest;
      const { headers = {}, method = HttpMethod.GET, username, password, withCredentials, timeout, responseType, beforeSend, useXDR, json } = options;
      let body = options.body;
      const sync = !!options.sync;
      let aborted = false;
      let timeoutTimer;
      const failureResponse = {
          body: {},
          headers: {},
          statusCode: 0,
          method,
          url,
          rawRequest: xhr
      };
      if (xhr === null) {
          if (useXDR) {
              xhr = new nativeXDomainRequest();
          }
          else {
              xhr = new nativeXMLHttpRequest();
          }
      }
      if (json === true) {
          if (headers.accept || headers.Accept) {
              headers.Accept = 'application/json';
          }
          if (method !== HttpMethod.GET && method !== HttpMethod.HEAD) {
              if (headers['content-type'] || headers['Content-Type']) {
                  headers['Content-Type'] = 'application/json';
              }
              body = JSON.stringify(body);
          }
      }
      let called = false;
      const callbackOnce = function (err, response, cbBody) {
          if (!called) {
              called = true;
              callback(err, response, cbBody);
          }
      };
      function getBody() {
          // Chrome with requestType=blob throws errors arround when even testing access to responseText
          let responseBody;
          if (xhr.response) {
              responseBody = xhr.response;
          }
          else {
              responseBody = xhr.responseText || getXml(xhr);
          }
          if (json) {
              try {
                  responseBody = JSON.parse(responseBody);
              }
              catch (err) {
                  console.log('JSON parse error: ', err);
              }
          }
          return responseBody;
      }
      function onLoad() {
          if (aborted) {
              return;
          }
          let status;
          let response = failureResponse;
          let err;
          clearTimeout(timeoutTimer);
          if (useXDR && xhr.status === undefined) {
              // IE8 CORS GET successful response doesn't have a status field, but body is fine
              status = 200;
          }
          else {
              status = xhr.status === 1223 ? 204 : xhr.status;
          }
          if (status !== 0) {
              response = {
                  body: getBody(),
                  statusCode: status,
                  method,
                  headers: {},
                  url,
                  rawRequest: xhr
              };
              if (xhr.getAllResponseHeaders) {
                  // xhr can in fact be XDR for CORS in IE
                  response.headers = parseHeaders(xhr.getAllResponseHeaders());
              }
          }
          else {
              err = new Error('Internal XMLHttpRequest Error');
          }
          return callbackOnce(err, response, response.body);
      }
      function onError(err) {
          clearTimeout(timeoutTimer);
          if (!(err instanceof Error)) {
              err = new Error('' + (err || 'Unknown XMLHttpRequest Error'));
          }
          err.statusCode = 0;
          return callbackOnce(err, failureResponse, failureResponse.body);
      }
      xhr.onreadystatechange = () => {
          if (xhr.readyState === ReadyState.DONE) {
              setTimeout(onLoad, 0);
          }
      };
      xhr.onload = onLoad;
      xhr.onerror = onError;
      // IE9 must have onprogress be set to a unique function.
      // tslint:disable-next-line:no-empty
      xhr.onprogress = () => { };
      xhr.onabort = () => {
          aborted = true;
      };
      xhr.ontimeout = onError;
      xhr.open(method, url, !sync, username, password);
      if (!sync) {
          xhr.withCredentials = !!withCredentials;
      }
      // Cannot set timeout with sync request
      // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
      // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
      if (!sync && timeout && timeout > 0) {
          timeoutTimer = setTimeout(() => {
              if (aborted) {
                  return;
              }
              aborted = true; // IE9 may still call readystatechange
              xhr.abort();
              const err = new Error('XMLHttpRequest timeout');
              err.code = 'ETIMEDOUT';
              onError(err);
          }, timeout);
      }
      if (xhr.setRequestHeader) {
          for (const key in headers) {
              if (headers.hasOwnProperty(key)) {
                  xhr.setRequestHeader(key, headers[key]);
              }
          }
      }
      else if (headers && isEmpty(headers)) {
          throw new Error('Headers cannot be set on an XDomainRequest object');
      }
      if (responseType) {
          xhr.responseType = responseType;
      }
      if (beforeSend && typeof options.beforeSend === 'function') {
          beforeSend(xhr);
      }
      // Microsoft Edge browser sends "undefined" when send is called with undefined value.
      // XMLHttpRequest spec says to pass null as body to indicate no body
      // See https://github.com/naugtur/xhr/issues/100.
      xhr.send(body || null);
      return xhr;
  }
  // tslint:disable-next-line:no-empty
  function noop() { }
  function isEmpty(obj) {
      for (const index in obj) {
          if (obj.hasOwnProperty(index)) {
              return false;
          }
      }
      return true;
  }
  function getXml(xhr) {
      // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
      // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
      try {
          if (xhr.responseType === 'document') {
              return xhr.responseXML;
          }
          const firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === 'parsererror';
          if (xhr.responseType === '' && !firefoxBugTakenEffect) {
              return xhr.responseXML;
          }
      }
      catch (err) {
          console.log('getXml: ', err);
      }
      return null;
  }
  function isArray(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
  }
  function parseHeaders(headers) {
      if (!headers) {
          return {};
      }
      const result = {};
      headers.trim().split('\n').forEach((row) => {
          const index = row.indexOf(':'), key = row.slice(0, index).trim().toLowerCase(), value = row.slice(index + 1).trim();
          if (typeof (result[key]) === 'undefined') {
              result[key] = value;
          }
          else if (isArray(result[key])) {
              result[key].push(value);
          }
          else {
              result[key] = [result[key], value];
          }
      });
      return result;
  }
  //# sourceMappingURL=index.js.map

  const BASEURL = 'http://me.dev.com:9091';
  const REQUESTPATH = '/logging';
  //# sourceMappingURL=API.js.map

  class LoggerBasicInfo {
      constructor() {
          this.trackId = window.TRACKID;
          this.location = {
              href: window.location.href,
              host: window.location.host,
              hostname: window.location.hostname,
              protocol: window.location.protocol,
              origin: window.location.origin,
              port: window.location.port,
              pathname: window.location.pathname,
              hash: window.location.hash,
              search: window.location.search
          };
      }
  }
  //# sourceMappingURL=LoggerBasicInfo.js.map

  class PageSize {
      constructor() {
          this.sizeRecords = [];
      }
      setPageSize(w, h) {
          this.sizeRecords.push({ w, h });
      }
      /**
       * Get page size before n times resize
       * @param count resize times count
       */
      getPageSizeBeforeResize(count) {
          return this.sizeRecords.slice(this.sizeRecords.length - count - 1, this.sizeRecords.length - count)[0];
      }
      // TODO clear obsolete scroll records
      clearRecords() {
          this.sizeRecords.length = 0;
      }
  }
  const pageSize = new PageSize();
  //# sourceMappingURL=pageSize.js.map

  class PageScroll {
      constructor() {
          this.scrollRecords = [];
      }
      setPageScroll(scrollX, scrollY) {
          this.scrollRecords.push({ x: scrollX, y: scrollY });
      }
      /**
       * Get page scroll position before n times scroll
       * @param count scroll times count
       */
      getPageScrollPositionBeforeScroll(count) {
          return this.scrollRecords.slice(this.scrollRecords.length - count - 1, this.scrollRecords.length - count)[0];
      }
      // TODO clear obsolete scroll records
      clearRecords() {
          this.scrollRecords.length = 0;
      }
  }
  const pageScroll = new PageScroll();
  //# sourceMappingURL=pageScroll.js.map

  window.addEventListener('error', (error) => {
      getBehaviorRecords()
          .then((records) => {
          let resizeCount = 0;
          let scrollCount = 0;
          records.forEach((record) => {
              if (record.TrackType === TrackType.EVENT_RESIZE) {
                  resizeCount++;
              }
              if (record.TrackType === TrackType.EVENT_SCROLL) {
                  scrollCount++;
              }
          });
          const initialWindowSize = pageSize.getPageSizeBeforeResize(resizeCount);
          const initialScroll = pageScroll.getPageScrollPositionBeforeScroll(scrollCount);
          console.log('resizeCount: ', resizeCount);
          console.log('scrollCount: ', scrollCount);
          console.log('initialWindowSize: ', initialWindowSize);
          console.log('initialScroll: ', initialScroll);
          const errorTrackInfo = {
              info: new LoggerBasicInfo(),
              track: {
                  error: new LoggerError(TrackType.ERROR, error),
                  behaviors: records
              }
          };
          console.log('records within error happened 10s: ', JSON.stringify(errorTrackInfo));
          XHR(BASEURL + REQUESTPATH, {
              method: HttpMethod.POST,
              body: JSON.stringify(errorTrackInfo)
          }, (err, response) => {
              if (err) {
                  console.log('error report error: ', err);
                  return;
              }
              console.log('error report response: ', response);
          });
      })
          .catch((err) => {
          console.log(`get record has err: `, err);
      });
  });
  //# sourceMappingURL=errorListener.js.map

  var NodeType;
  (function (NodeType) {
      NodeType[NodeType["Document"] = 0] = "Document";
      NodeType[NodeType["DocumentType"] = 1] = "DocumentType";
      NodeType[NodeType["Element"] = 2] = "Element";
      NodeType[NodeType["Text"] = 3] = "Text";
      NodeType[NodeType["CDATA"] = 4] = "CDATA";
      NodeType[NodeType["Comment"] = 5] = "Comment";
  })(NodeType || (NodeType = {}));
  //# sourceMappingURL=types.js.map

  let _id = 1;
  function getId() {
      return _id++;
  }
  function getAbsoluteRef(document, attributeValue) {
      if (attributeValue.trim() === '') {
          return attributeValue;
      }
      let ancher = document.createElement('a');
      ancher.href = attributeValue;
      const href = ancher.href;
      return href;
  }
  function getAbsoluteSrcset(document, attributeValue) {
      if (attributeValue.trim() === '') {
          return attributeValue;
      }
      const srcsets = attributeValue.split(',');
      const absoluteSrcsets = srcsets.map((src) => {
          const urlAndDescriptor = src.trim().split(' ');
          const absUrl = getAbsoluteRef(document, urlAndDescriptor[0]);
          if (urlAndDescriptor.length === 1) {
              return `${absUrl}`;
          }
          else if (urlAndDescriptor.length === 2) {
              return `${absUrl} ${urlAndDescriptor[1]}`;
          }
          return '';
      }).join(',');
      return absoluteSrcsets;
  }
  function extractOrigin(url) {
      let origin;
      if (url.indexOf('//') > -1) {
          // example: "https://www.google.com/maps" => "https://www.google.com"
          origin = url
              .split('/')
              .slice(0, 3)
              .join('/');
      }
      else {
          origin = url.split('/')[0];
      }
      origin = origin.split('?')[0];
      return origin;
  }
  const URL_IN_CSS_REF = /url\((?:'([^']*)'|"([^"]*)"|([^)]*))\)/gm;
  const RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/;
  const DATA_URI = /^(data:)([\w\/\+\-]+);(charset=[\w-]+|base64).*,(.*)/i;
  function getAbsoluteStylesheet(cssText, href) {
      return cssText.replace(URL_IN_CSS_REF, (origin, path1, path2, path3) => {
          const filePath = path1 || path2 || path3;
          if (!filePath) {
              return origin;
          }
          if (!RELATIVE_PATH.test(filePath)) {
              return `url('${filePath}')`;
          }
          if (DATA_URI.test(filePath)) {
              return `url(${filePath})`;
          }
          if (filePath[0] === '/') {
              return `url('${extractOrigin(href) + filePath}')`;
          }
          const stack = href.split('/');
          const parts = filePath.split('/');
          stack.pop();
          for (const part of parts) {
              if (part === '.') {
                  continue;
              }
              else if (part === '.') {
                  stack.pop();
              }
              else {
                  stack.push(part);
              }
          }
          return `url('${stack.join('/')}')`;
      });
  }
  function getCSSRulesString(styleSheet) {
      try {
          const rules = styleSheet.rules || styleSheet.cssRules;
          return rules ?
              Array.from(rules).reduce((prev, cur) => prev + getCSSRuleString(cur), '') : null;
      }
      catch (error) {
          return null;
      }
  }
  function getCSSRuleString(rule) {
      return isCSSImportRule(rule) ?
          getCSSRulesString(rule.styleSheet) || ''
          : rule.cssText;
  }
  function isCSSImportRule(rule) {
      return 'styleSheet' in rule;
  }
  function isSVGElement(element) {
      return element.tagName === 'svg' || element instanceof SVGElement;
  }
  function serializeNode(node, document, blockClass, inlineStylesheet, maskAllInputs) {
      switch (node.nodeType) {
          case node.DOCUMENT_NODE:
              return {
                  type: NodeType.Document,
                  childNodes: []
              };
          case node.DOCUMENT_TYPE_NODE:
              return {
                  // Reference: https://developer.mozilla.org/en-US/docs/Web/API/DocumentType
                  type: NodeType.DocumentType,
                  name: node.name,
                  publicId: node.publicId,
                  systemId: node.systemId
              };
          case node.ELEMENT_NODE:
              let needBlock = false;
              if (typeof blockClass === 'string') {
                  needBlock = node.classList.contains(blockClass);
              }
              else {
                  node.classList.forEach((className) => {
                      if (blockClass.test(className)) {
                          needBlock = true;
                      }
                  });
              }
              const tagName = node.tagName.toLowerCase();
              const attributes = {};
              for (const { name, value } of Array.from(node.attributes)) {
                  if (name === 'src' || name === 'href') {
                      attributes[name] = getAbsoluteRef(document, value);
                  }
                  else if (name === 'srcset') {
                      attributes[name] = getAbsoluteSrcset(document, value);
                  }
                  else if (name === 'style') {
                      attributes[name] = getAbsoluteStylesheet(value, window.location.href);
                  }
                  else {
                      attributes[name] = value;
                  }
              }
              if (tagName === 'link' && inlineStylesheet) {
                  const styleSheet = Array.from(document.styleSheets).find((s) => {
                      return s.href === node.href;
                  });
                  const cssText = getCSSRulesString(styleSheet);
                  if (cssText) {
                      delete attributes.rel;
                      delete attributes.href;
                      attributes._cssText = getAbsoluteStylesheet(cssText, styleSheet.href);
                  }
              }
              if (tagName === 'style' &&
                  node.sheet &&
                  !(node.innerText ||
                      node.textContent ||
                      '').trim().length) {
                  const cssText = getCSSRulesString(node.sheet);
                  if (cssText) {
                      attributes._cssText = getAbsoluteStylesheet(cssText, location.href);
                  }
              }
              if (tagName === 'input' ||
                  tagName === 'textarea' ||
                  tagName === 'select') {
                  const value = node.value;
                  if (attributes.type !== 'radio' &&
                      attributes.type !== 'checkbox' &&
                      value) {
                      attributes.value = maskAllInputs ? '*'.repeat(value.length) : value;
                  }
                  else if (node.checked) {
                      attributes.checked = node.checked;
                  }
              }
              if (tagName === 'option') {
                  const selectValue = node.parentElement;
                  if (attributes.value === selectValue.value) {
                      attributes.selected = node.selected;
                  }
              }
              if (tagName === 'canvas') {
                  attributes.art_dataURL = node.toDataURL();
              }
              if (needBlock) {
                  const { width, height } = node.getBoundingClientRect();
                  attributes.art_width = `${width}px`;
                  attributes.art_height = `${height}px`;
              }
              return {
                  type: NodeType.Element,
                  tagName,
                  attributes,
                  childNodes: [],
                  isSVG: isSVGElement(node) || undefined,
                  needBlock
              };
          case node.TEXT_NODE:
              // The parent node may not be a element which has a tagName attribute.
              // So just let it be undefined which is ok in this use case.
              const parentTagName = node.parentNode && node.parentNode.tagName;
              let textContent = node.textContent;
              const isStyle = parentTagName === 'STYLE' ? true : undefined;
              if (isStyle && textContent) {
                  textContent = getAbsoluteStylesheet(textContent, window.location.href);
              }
              if (parentTagName === 'SCRIPT') {
                  textContent = 'SCRIPT_PLACEHOLDER';
              }
              return {
                  type: NodeType.Text,
                  textContent: textContent || '',
                  isStyle
              };
          case node.CDATA_SECTION_NODE:
              return {
                  type: NodeType.CDATA,
                  textContent: ''
              };
          case node.COMMENT_NODE:
              return {
                  type: NodeType.Comment,
                  textContent: node.textContent || ''
              };
          default:
              return false;
      }
  }
  function serializeNodeWithId(node, document, map, blockClass, skipChild = false, inlineStylesheet = true, maskAllInputs = false) {
      const serializedNode = serializeNode(node, document, blockClass, inlineStylesheet, maskAllInputs);
      if (!serializedNode) {
          return null;
      }
      let id;
      if ('__sn' in node) {
          id = node.__sn.id;
      }
      else {
          id = getId();
      }
      const serializedNodeWithId = Object.assign(serializedNode, { id });
      node.__sn = serializedNodeWithId;
      map[id] = node;
      let recordChild = !skipChild;
      if (serializedNodeWithId.type === NodeType.Element) {
          recordChild = !skipChild && !serializedNodeWithId.needBlock;
          delete serializedNodeWithId.needBlock;
      }
      if ((serializedNodeWithId.type === NodeType.Document ||
          serializedNodeWithId.type === NodeType.Element) &&
          recordChild) {
          for (const childNode of Array.from(node.childNodes)) {
              const serializedChildNode = serializeNodeWithId(childNode, document, map, blockClass, skipChild, inlineStylesheet, maskAllInputs);
              if (serializedChildNode) {
                  serializedNodeWithId.childNodes.push(serializedChildNode);
              }
          }
      }
      return serializedNodeWithId;
  }
  //# sourceMappingURL=serializeNodeWithId.js.map

  function snapshot(node, blockClass = 'art-block', inlineStylesheet = true, maskAllInputs = false) {
      const idNodeMap = {};
      return [
          serializeNodeWithId(node, node, idNodeMap, blockClass, false, inlineStylesheet, maskAllInputs),
          idNodeMap
      ];
  }
  //# sourceMappingURL=snapshot.js.map

  // const isNodeNotElement = (node: Node | Element) => {
  //   return node instanceof Node && !(node instanceof Element);
  // };
  // const getNodeInfo = (node: Node) => {
  //   if (isNodeNotElement(node)) {
  //     if (node.parentElement) {
  //       return unique(node.parentElement) + ', nodeValue: ' + node.nodeValue;
  //     } else { return ''; }
  //   }
  //   return unique(node as Element);
  // };
  // const handleNode = (node: NodeList | Node) => {
  //   console.log('nodenode: ', node);
  //   if (node instanceof Node) {
  //     return getNodeInfo(node);
  //   }
  //   return JSON.stringify(
  //     Array.prototype.map.call(node, (n: Node | Element) => {
  //       return getNodeInfo(n);
  //     })
  //   );
  // };
  // export class LoggerMutation extends LoggerBase {
  //   constructor(TrackType: number, mutationRecord: MutationRecord) {
  //     super(TrackType);
  //     this.type = mutationRecord.type;
  //     this.target = handleNode(mutationRecord.target);
  //     this.addedNode = handleNode(mutationRecord.addedNodes);
  //     this.removedNodes = handleNode(mutationRecord.removedNodes);
  //     this.attributeName = mutationRecord.attributeName;
  //     this.attributeNamespace = mutationRecord.attributeNamespace;
  //     this.previousSibling = mutationRecord.previousSibling ? handleNode(mutationRecord.previousSibling) : null;
  //     this.nextSibling = mutationRecord.nextSibling ? handleNode(mutationRecord.nextSibling) : null;
  //     this.oldValue = mutationRecord.oldValue;
  //   }
  //   public type: string;
  //   public target: string;
  //   public addedNode: string;
  //   public removedNodes: string;
  //   public attributeName: string | null;
  //   public attributeNamespace: string | null;
  //   public previousSibling: string | null;
  //   public nextSibling: string | null;
  //   public oldValue: string | null;
  // }
  var MutationType;
  (function (MutationType) {
      MutationType["attributes"] = "attributes";
      MutationType["characterData"] = "characterData";
      MutationType["childList"] = "childList";
  })(MutationType || (MutationType = {}));
  class LoggerMutation extends LoggerBase {
      constructor(TrackType, mutationData) {
          super(TrackType);
          this.mutationType = mutationData.type;
          this.target = mutationData.target;
          this.addedNodes = mutationData.addedNodes;
          this.removedNodes = mutationData.removedNodes;
          this.attributeName = mutationData.attributeName;
          // this.attributeNamespace = mutationData;
          this.previousSibling = mutationData.previousSibling;
          this.nextSibling = mutationData.nextSibling;
          this.oldValue = mutationData.oldValue;
          this.newValue = mutationData.newValue;
      }
  }
  //# sourceMappingURL=LoggerMutation.js.map

  //# sourceMappingURL=utils.js.map

  function isSerializedNode(node) {
      return '__sn' in node;
  }
  function initMutationObserver(blockClass = 'art-block', inlineStylesheet = true, maskAllInputs = false) {
      const targetNode = document.querySelector('body');
      let styleAttrMutationTimeout;
      const storeMutation = (mutationData) => {
          const mutaionLog = new LoggerMutation(TrackType.MUTATION, mutationData);
          iDBStoreInstance.set(OBJECTNAME, mutaionLog)
              .then(() => {
              console.log('mutaion log added');
          })
              .catch((err) => {
              console.log('mutaion log err: ', err);
          });
          if (mutationData.type === 'attributes' && mutationData.attributeName === 'style') {
              styleAttrMutationTimeout = window.setTimeout(() => {
                  window.clearTimeout(styleAttrMutationTimeout);
                  styleAttrMutationTimeout = null;
              }, 200);
          }
      };
      const callback = (mutations) => {
          mutations.forEach((mutation) => {
              // if (mutation.type === 'attributes' &&
              //   mutation.attributeName === 'style' &&
              //   styleAttrMutationTimeout
              // ) { return; }
              // storeMutation(mutation);
              console.log('mutation: ', mutation);
              const { type, target, attributeName, oldValue, addedNodes, removedNodes, previousSibling, nextSibling } = mutation;
              let mutationData;
              switch (type) {
                  case MutationType.attributes:
                      const attribute = target.getAttribute(attributeName);
                      if (attribute === oldValue) {
                          console.log('attribute not changed');
                          return;
                      }
                      mutationData = {
                          type: MutationType.attributes,
                          target: nodeMirror.getId(target),
                          attributeName,
                          oldValue,
                          newValue: attribute,
                          addedNodes: [],
                          removedNodes: [],
                          previousSibling: null,
                          nextSibling: null
                      };
                      console.log('mutationData attributes: ', mutationData);
                      break;
                  case MutationType.characterData:
                      const characterValue = target.textContent;
                      if (characterValue === oldValue) {
                          console.log('character not changed');
                          return;
                      }
                      mutationData = {
                          type: MutationType.characterData,
                          target: nodeMirror.getId(target),
                          attributeName: null,
                          oldValue,
                          newValue: characterValue,
                          addedNodes: [],
                          removedNodes: [],
                          previousSibling: null,
                          nextSibling: null
                      };
                      console.log('mutationData characterData: ', mutationData);
                      break;
                  case MutationType.childList:
                      let targetNode;
                      if (!isSerializedNode(target)) {
                          targetNode = serializeNodeWithId(target, document, nodeMirror.map, blockClass, true, inlineStylesheet, maskAllInputs);
                      }
                      const serializedAddedNodes = Array.from(addedNodes).map((node) => {
                          return serializeNodeWithId(node, document, nodeMirror.map, blockClass, false, inlineStylesheet, maskAllInputs);
                      });
                      const serializedRemovedNodes = Array.from(removedNodes).map((node) => {
                          nodeMirror.removeNodeFromMap(node);
                          return nodeMirror.getId(node);
                      });
                      mutationData = {
                          type: MutationType.childList,
                          target: targetNode || nodeMirror.getId(target),
                          attributeName: null,
                          oldValue: null,
                          newValue: null,
                          addedNodes: serializedAddedNodes,
                          removedNodes: serializedRemovedNodes,
                          previousSibling: previousSibling === null ? previousSibling : nodeMirror.getId(previousSibling),
                          nextSibling: nextSibling === null ? nextSibling : nodeMirror.getId(nextSibling)
                      };
                      console.log('mutationData childList: ', mutationData);
                      break;
                  default:
                      break;
              }
              if (styleAttrMutationTimeout) {
                  return;
              }
              // @ts-ignore
              storeMutation(mutationData);
          });
      };
      const config = {
          attributes: true,
          attributeOldValue: true,
          childList: true,
          characterData: true,
          characterDataOldValue: true,
          subtree: true
      };
      const mutationObserver = new MutationObserver(callback);
      if (targetNode) {
          mutationObserver.observe(targetNode, config);
      }
  }
  //# sourceMappingURL=index.js.map

  class LoggerUIEvent extends LoggerEvent {
      constructor(TrackType, uiEvent) {
          super(TrackType, uiEvent);
          const { detail } = uiEvent;
          this.detail = detail;
      }
  }
  //# sourceMappingURL=LoggerUIEvent.js.map

  class LoggerResizeEvent extends LoggerUIEvent {
      constructor(TrackType, resizeEvent) {
          super(TrackType, resizeEvent);
          this.width = document.defaultView.innerWidth;
          this.height = document.defaultView.innerHeight;
      }
  }
  //# sourceMappingURL=LoggerResizeEvent.js.map

  /**
   * list all standard events. Art error monitor will only listen to part of following
   * events, listing all of them just for completeness.
   */
  var Event$1;
  (function (Event) {
      Event["abort"] = "abort";
      Event["error"] = "error";
      Event["load"] = "load";
      Event["unload"] = "unload";
      Event["afterprint"] = "afterprint";
      Event["appinstalled"] = "appinstalled";
      Event["audioend"] = "audioend";
      Event["audiostart"] = "audiostart";
      Event["beforeprint"] = "beforeprint";
      Event["canplay"] = "canplay";
      Event["canplaythrough"] = "canplaythrough";
      Event["change"] = "change";
      Event["chargingchange"] = "chargingchange";
      Event["chargingtimechange"] = "chargingtimechange";
      Event["dischargingtimechange"] = "dischargingtimechange";
      Event["levelchange"] = "levelchange";
      Event["open"] = "open";
      Event["close"] = "close";
      Event["blocked"] = "blocked";
      Event["complete"] = "complete";
      Event["success"] = "success";
      Event["upgradeneeded"] = "upgradeneeded";
      Event["versionchange"] = "versionchange";
      Event["devicechange"] = "devicechange";
      Event["DOMContentLoaded"] = "DOMContentLoaded";
      Event["durationchange"] = "durationchange";
      Event["emptied"] = "emptied";
      Event["ended"] = "ended";
      Event["end"] = "end";
      Event["fullscreenchange"] = "fullscreenchange";
      Event["fullscreenerror"] = "fullscreenerror";
      Event["input"] = "input";
      Event["invalid"] = "invalid";
      Event["languagechange"] = "languagechange";
      Event["loadeddata"] = "loadeddata";
      Event["loadedmetadata"] = "loadedmetadata";
      Event["online"] = "online";
      Event["offline"] = "offline";
      Event["orientationchange"] = "orientationchange";
      Event["play"] = "play";
      Event["playing"] = "playing";
      Event["pause"] = "pause";
      Event["ratechange"] = "ratechange";
      Event["seeked"] = "seeked";
      Event["seeking"] = "seeking";
      Event["stalled"] = "stalled";
      Event["suspend"] = "suspend";
      Event["timeupdate"] = "timeupdate";
      Event["pointerlockchange"] = "pointerlockchange";
      Event["pointerlockerror"] = "pointerlockerror";
      Event["readystatechange"] = "readystatechange";
      Event["reset"] = "reset";
      Event["selectstart"] = "selectstart";
      Event["selectionchange"] = "selectionchange";
      Event["slotchange"] = "slotchange";
      Event["start"] = "start";
      Event["soundend"] = "soundend";
      Event["soundstart"] = "soundstart";
      Event["speechend"] = "speechend";
      Event["speechstart"] = "speechstart";
      Event["voiceschanged"] = "voiceschanged";
      Event["volumechange"] = "volumechange";
      Event["waiting"] = "waiting";
      Event["submit"] = "submit";
      Event["visibilitychange"] = "visibilitychange";
      Event["resize"] = "resize";
      Event["scroll"] = "scroll";
  })(Event$1 || (Event$1 = {}));
  var UIEvent;
  (function (UIEvent) {
      // 'abort' = 'abort',
      // 'error' = 'error',
      // 'load' = 'load',
      // 'unload' = 'unload',
      // 'resize' = 'resize',
      // 'scroll' = 'scroll',
      UIEvent["select"] = "select";
      UIEvent["DOMActivate"] = "DOMActivate";
  })(UIEvent || (UIEvent = {}));
  var ProgressEvent;
  (function (ProgressEvent) {
      ProgressEvent["abort"] = "abort";
      ProgressEvent["error"] = "error";
      ProgressEvent["load"] = "load";
      ProgressEvent["loadstart"] = "loadstart";
      ProgressEvent["loadend"] = "loadend";
      ProgressEvent["timeout"] = "timeout";
  })(ProgressEvent || (ProgressEvent = {}));
  // experimental
  var AnimationEvent;
  (function (AnimationEvent) {
      AnimationEvent["animationcancel"] = "animationcancel";
      AnimationEvent["animationend"] = "animationend";
      AnimationEvent["animationiteration"] = "animationiteration";
      AnimationEvent["animationstart"] = "animationstart";
  })(AnimationEvent || (AnimationEvent = {}));
  var BeforeUnloadEvent;
  (function (BeforeUnloadEvent) {
      BeforeUnloadEvent["beforeunload"] = "beforeunload";
  })(BeforeUnloadEvent || (BeforeUnloadEvent = {}));
  var TimeEvent;
  (function (TimeEvent) {
      TimeEvent["beginEvent"] = "beginEvent";
      TimeEvent["endEvent"] = "endEvent";
      TimeEvent["repeatEvent"] = "repeatEvent";
  })(TimeEvent || (TimeEvent = {}));
  // experimental
  var FocusEvent;
  (function (FocusEvent) {
      FocusEvent["blur"] = "blur";
      FocusEvent["focus"] = "focus";
      FocusEvent["focusin"] = "focusin";
      FocusEvent["focusout"] = "focusout";
      FocusEvent["DOMFocusIn"] = "DOMFocusIn";
      FocusEvent["DOMFocusOut"] = "DOMFocusOut";
  })(FocusEvent || (FocusEvent = {}));
  var SpeechSynthesisEvent;
  (function (SpeechSynthesisEvent) {
      SpeechSynthesisEvent["boundary"] = "boundary";
      SpeechSynthesisEvent["start"] = "start";
      SpeechSynthesisEvent["end"] = "end";
      SpeechSynthesisEvent["mark"] = "mark";
      SpeechSynthesisEvent["pause"] = "pause";
      SpeechSynthesisEvent["resume"] = "resume";
  })(SpeechSynthesisEvent || (SpeechSynthesisEvent = {}));
  var MouseEvent;
  (function (MouseEvent) {
      MouseEvent["click"] = "click";
      MouseEvent["contextmenu"] = "contextmenu";
      MouseEvent["dblclick"] = "dblclick";
      MouseEvent["mousedown"] = "mousedown";
      MouseEvent["mouseenter"] = "mouseenter";
      MouseEvent["mouseleave"] = "mouseleave";
      MouseEvent["mousemove"] = "mousemove";
      MouseEvent["mouseout"] = "mouseout";
      MouseEvent["mouseover"] = "mouseover";
      MouseEvent["mouseup"] = "mouseup";
      MouseEvent["show"] = "show";
  })(MouseEvent || (MouseEvent = {}));
  var CompositionEvent;
  (function (CompositionEvent) {
      CompositionEvent["compositionstart"] = "compositionstart";
      CompositionEvent["compositionupdate"] = "compositionupdate";
      CompositionEvent["compositionend"] = "compositionend";
  })(CompositionEvent || (CompositionEvent = {}));
  // experimental
  var ClipboardEvent;
  (function (ClipboardEvent) {
      ClipboardEvent["copy"] = "copy";
      ClipboardEvent["cut"] = "cut";
      ClipboardEvent["paste"] = "paste";
  })(ClipboardEvent || (ClipboardEvent = {}));
  // experimental
  var DeviceMotionEvent;
  (function (DeviceMotionEvent) {
      DeviceMotionEvent["devicemotion"] = "devicemotion";
      DeviceMotionEvent["deviceorientation"] = "deviceorientation";
  })(DeviceMotionEvent || (DeviceMotionEvent = {}));
  var MutationEvent;
  (function (MutationEvent) {
      MutationEvent["DOMAttrModified"] = "DOMAttrModified";
      MutationEvent["DOMCharacterDataModified"] = "DOMCharacterDataModified";
      MutationEvent["DOMNodeInserted"] = "DOMNodeInserted";
      MutationEvent["DOMNodeInsertedIntoDocument"] = "DOMNodeInsertedIntoDocument";
      MutationEvent["DOMNodeRemoved"] = "DOMNodeRemoved";
      MutationEvent["DOMNodeRemovedFromDocument"] = "DOMNodeRemovedFromDocument";
      MutationEvent["DOMSubtreeModified"] = "DOMSubtreeModified";
  })(MutationEvent || (MutationEvent = {}));
  var DragEvent;
  (function (DragEvent) {
      DragEvent["drag"] = "drag";
      DragEvent["dragend"] = "dragend";
      DragEvent["dragenter"] = "dragenter";
      DragEvent["dragleave"] = "dragleave";
      DragEvent["dragover"] = "dragover";
      DragEvent["dragstart"] = "dragstart";
      DragEvent["drop"] = "drop";
  })(DragEvent || (DragEvent = {}));
  // experimental
  var SpeechSynthesisErrorEvent;
  (function (SpeechSynthesisErrorEvent) {
      SpeechSynthesisErrorEvent["error"] = "error";
  })(SpeechSynthesisErrorEvent || (SpeechSynthesisErrorEvent = {}));
  // experimental
  var GamepadEvent;
  (function (GamepadEvent) {
      GamepadEvent["gamepadconnected"] = "gamepadconnected";
      GamepadEvent["gamepaddisconnected"] = "gamepaddisconnected";
  })(GamepadEvent || (GamepadEvent = {}));
  var PointerEvent;
  (function (PointerEvent) {
      PointerEvent["gotpointercapture"] = "gotpointercapture";
      PointerEvent["lostpointercapture"] = "lostpointercapture";
      PointerEvent["pointercancel"] = "pointercancel";
      PointerEvent["pointerdown"] = "pointerdown";
      PointerEvent["pointerenter"] = "pointerenter";
      PointerEvent["pointerleave"] = "pointerleave";
      PointerEvent["pointermove"] = "pointermove";
      PointerEvent["pointerout"] = "pointerout";
      PointerEvent["pointerover"] = "pointerover";
      PointerEvent["pointerup"] = "pointerup";
  })(PointerEvent || (PointerEvent = {}));
  var HashChangeEvent;
  (function (HashChangeEvent) {
      HashChangeEvent["hashchange"] = "hashchange";
  })(HashChangeEvent || (HashChangeEvent = {}));
  var KeyboardEvent;
  (function (KeyboardEvent) {
      KeyboardEvent["keydown"] = "keydown";
      KeyboardEvent["keypress"] = "keypress";
      KeyboardEvent["keyup"] = "keyup";
  })(KeyboardEvent || (KeyboardEvent = {}));
  var MessageEvent;
  (function (MessageEvent) {
      MessageEvent["message"] = "message";
      MessageEvent["messageerror"] = "messageerror";
  })(MessageEvent || (MessageEvent = {}));
  var ServiceWorkerMessageEventOrExtendableMessageEvent;
  (function (ServiceWorkerMessageEventOrExtendableMessageEvent) {
      ServiceWorkerMessageEventOrExtendableMessageEvent["message"] = "message"; // experimental
  })(ServiceWorkerMessageEventOrExtendableMessageEvent || (ServiceWorkerMessageEventOrExtendableMessageEvent = {}));
  // experimental
  var SpeechRecognitionEvent;
  (function (SpeechRecognitionEvent) {
      SpeechRecognitionEvent["nomatch"] = "nomatch";
      SpeechRecognitionEvent["result"] = "result";
  })(SpeechRecognitionEvent || (SpeechRecognitionEvent = {}));
  // experimental
  var NotificationEvent;
  (function (NotificationEvent) {
      NotificationEvent["notificationclick"] = "notificationclick";
  })(NotificationEvent || (NotificationEvent = {}));
  var PageTransitionEvent;
  (function (PageTransitionEvent) {
      PageTransitionEvent["pagehide"] = "pagehide";
      PageTransitionEvent["pageshow"] = "pageshow";
  })(PageTransitionEvent || (PageTransitionEvent = {}));
  var PopStateEvent;
  (function (PopStateEvent) {
      PopStateEvent["popstate"] = "popstate";
      PopStateEvent["progress"] = "progress";
  })(PopStateEvent || (PopStateEvent = {}));
  // experimental
  var PushEvent;
  (function (PushEvent) {
      PushEvent["push"] = "push";
      PushEvent["pushsubscriptionchange"] = "pushsubscriptionchange";
  })(PushEvent || (PushEvent = {}));
  var Performance;
  (function (Performance) {
      Performance["resourcetimingbufferfull"] = "resourcetimingbufferfull";
  })(Performance || (Performance = {}));
  var StorageEvent;
  (function (StorageEvent) {
      StorageEvent["storage"] = "storage";
  })(StorageEvent || (StorageEvent = {}));
  var SVGEvent;
  (function (SVGEvent) {
      SVGEvent["SVGAbort"] = "SVGAbort";
      SVGEvent["SVGError"] = "SVGError";
      SVGEvent["SVGLoad"] = "SVGLoad";
      SVGEvent["SVGResize"] = "SVGResize";
      SVGEvent["SVGScroll"] = "SVGScroll";
      SVGEvent["SVGUnload"] = "SVGUnload";
  })(SVGEvent || (SVGEvent = {}));
  var SVGZoomEvent;
  (function (SVGZoomEvent) {
      SVGZoomEvent["SVGZoom"] = "SVGZoom";
  })(SVGZoomEvent || (SVGZoomEvent = {}));
  var TouchEvent;
  (function (TouchEvent) {
      TouchEvent["touchcancel"] = "touchcancel";
      TouchEvent["touchend"] = "touchend";
      TouchEvent["touchmove"] = "touchmove";
      TouchEvent["touchstart"] = "touchstart";
  })(TouchEvent || (TouchEvent = {}));
  // experimental
  var TransitionEvent;
  (function (TransitionEvent) {
      TransitionEvent["transitionend"] = "transitionend";
  })(TransitionEvent || (TransitionEvent = {}));
  // experimental
  var UserProximityEvent;
  (function (UserProximityEvent) {
      UserProximityEvent["userproximity"] = "userproximity";
  })(UserProximityEvent || (UserProximityEvent = {}));
  var WheelEvent;
  (function (WheelEvent) {
      WheelEvent["wheel"] = "wheel";
  })(WheelEvent || (WheelEvent = {}));
  var CustomEvent;
  (function (CustomEvent) {
      CustomEvent["statechange"] = "statechange";
  })(CustomEvent || (CustomEvent = {}));
  // deprecated
  // export enum AudioProcessingEvent {}
  // deprecated
  // export enum OfflineAudioCompletionEvent {
  //   'complete' = 'complete'
  // }
  // deprecated
  // export enum MutationNameEvent {
  //   'DOMAttributeNameChanged' = 'DOMAttributeNameChanged',
  //   'DOMElementNameChanged' = 'DOMElementNameChanged'
  // }
  //# sourceMappingURL=EventName.js.map

  function throttle(func, wait, options = {}) {
      let timeout = null;
      let previous = 0;
      // tslint:disable-next-line: only-arrow-functions
      return function (arg) {
          let now = Date.now();
          if (!previous && options.leading === false) {
              previous = now;
          }
          let remaining = wait - (now - previous);
          let context = this;
          let args = arguments;
          if (remaining <= 0 || remaining > wait) {
              if (timeout) {
                  window.clearTimeout(timeout);
                  timeout = null;
              }
              previous = now;
              func.apply(context, args);
          }
          else if (!timeout && options.trailing !== false) {
              timeout = window.setTimeout(() => {
                  previous = options.leading === false ? 0 : Date.now();
                  timeout = null;
                  func.apply(context, args);
              }, remaining);
          }
      };
  }
  //# sourceMappingURL=throttle.js.map

  function initResizeListener() {
      window.addEventListener(Event$1.resize, throttle((event) => {
          const resizeLog = new LoggerResizeEvent(TrackType.EVENT_RESIZE, event);
          pageSize.setPageSize(resizeLog.width, resizeLog.height);
          console.log('Log resize: ', resizeLog);
          iDBStoreInstance.set(OBJECTNAME, resizeLog)
              .then(() => {
              // console.log('resize log added');
          })
              .catch((err) => {
              console.log('resize log err: ', err);
          });
      }, 200));
  }
  //# sourceMappingURL=resize.js.map

  class LoggerScrollEvent extends LoggerEvent {
      constructor(TrackType, event) {
          super(TrackType, event);
          this.scrollX = window.scrollX;
          this.scrollY = window.scrollY;
      }
  }
  //# sourceMappingURL=LoggerScroll.js.map

  function initScrollListener() {
      window.addEventListener(Event$1.scroll, throttle((event) => {
          const loggerEvent = new LoggerScrollEvent(TrackType.EVENT_SCROLL, event);
          pageScroll.setPageScroll(loggerEvent.scrollX, loggerEvent.scrollY);
          console.log('log scroll: ', loggerEvent);
          iDBStoreInstance.set(OBJECTNAME, loggerEvent)
              .then(() => {
              // console.log('scroll log added');
          })
              .catch((err) => {
              console.log('scroll log err: ', err);
          });
      }, 200));
  }
  //# sourceMappingURL=scroll.js.map

  // import { getEventTargetInfo } from '../getEventTargetInfo';
  class LoggerMouseEvent extends LoggerUIEvent {
      constructor(TrackType, mouseEvent) {
          super(TrackType, mouseEvent);
          this.altKey = mouseEvent.altKey;
          this.button = mouseEvent.button;
          this.buttons = mouseEvent.buttons;
          this.clientX = mouseEvent.clientX;
          this.clientY = mouseEvent.clientY;
          this.ctrlKey = mouseEvent.ctrlKey;
          this.metaKey = mouseEvent.metaKey;
          this.movementX = mouseEvent.movementX;
          this.movementY = mouseEvent.movementY;
          this.offsetX = mouseEvent.offsetX;
          this.offsetY = mouseEvent.offsetY;
          this.pageX = mouseEvent.pageX;
          this.pageY = mouseEvent.pageY;
          // this.relatedTarget = getEventTargetInfo(mouseEvent.relatedTarget);
          this.relatedTarget = mouseEvent.relatedTarget ? nodeMirror.getId(mouseEvent.relatedTarget) : null;
          this.screenX = mouseEvent.screenX;
          this.screenY = mouseEvent.screenY;
          this.shiftKey = mouseEvent.shiftKey;
      }
  }
  //# sourceMappingURL=LoggerMouseEvent.js.map

  function initMouseListener() {
      window.addEventListener(MouseEvent.click, (event) => {
          const clickLog = new LoggerMouseEvent(TrackType.MOUSEEVENT_CLICK, event);
          console.log('log click: ', clickLog);
          iDBStoreInstance.set(OBJECTNAME, clickLog)
              .then(() => {
              // console.log('click log added');
          })
              .catch((err) => {
              console.log('click log err: ', err);
          });
      });
  }
  //# sourceMappingURL=mouseEvent.js.map

  class LoggerSelection extends LoggerEvent {
      constructor(TrackType, event, selection, direction) {
          super(TrackType, event);
          const { anchorNode, anchorOffset, focusNode, focusOffset, isCollapsed, rangeCount } = selection;
          this.anchorNode = !anchorNode ? null : nodeMirror.getId(anchorNode);
          this.anchorOffset = anchorOffset;
          this.focusNode = !focusNode ? null : nodeMirror.getId(focusNode);
          this.focusOffset = focusOffset;
          this.isCollapsed = isCollapsed;
          this.rangeCount = rangeCount;
          this.direction = direction;
      }
  }
  //# sourceMappingURL=LoggerSelection.js.map

  var SelectionDirection;
  (function (SelectionDirection) {
      SelectionDirection[SelectionDirection["forward"] = 0] = "forward";
      SelectionDirection[SelectionDirection["backward"] = 1] = "backward";
      SelectionDirection[SelectionDirection["collapsed"] = 2] = "collapsed";
      SelectionDirection[SelectionDirection["null"] = 3] = "null";
  })(SelectionDirection || (SelectionDirection = {}));
  //# sourceMappingURL=SelectionDirection.js.map

  function detectSelectionDirection(selection) {
      // console.log('selection: ', selection);
      const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
      if (anchorNode === null || focusNode === null) {
          return SelectionDirection.null;
      }
      const position = anchorNode.compareDocumentPosition(focusNode);
      // positon 0 if nodes are the same
      if ((position === 0 && anchorOffset > focusOffset) ||
          position === Node.DOCUMENT_POSITION_PRECEDING ||
          (position === (Node.DOCUMENT_POSITION_PRECEDING + Node.DOCUMENT_POSITION_CONTAINS))) {
          return SelectionDirection.backward;
      }
      else if (selection.isCollapsed) {
          return SelectionDirection.collapsed;
      }
      else {
          return SelectionDirection.forward;
      }
  }
  //# sourceMappingURL=detectSelectionDirection.js.map

  function isInputSelection() {
      const activeElement = document.activeElement;
      return activeElement instanceof HTMLInputElement || activeElement instanceof HTMLTextAreaElement;
  }
  function initSelectionListener() {
      document.addEventListener(Event$1.selectstart, (event) => {
          const selection = document.getSelection();
          if (selection === null) {
              return;
          }
          if (isInputSelection()) {
              return;
          }
          const direction = detectSelectionDirection(selection);
          const selectionStartLog = new LoggerSelection(TrackType.EVENT_SELECTIONSTART, event, selection, direction);
          console.log('selection start log: ', selectionStartLog);
          iDBStoreInstance.set(OBJECTNAME, selectionStartLog)
              .then(() => {
          })
              .catch((err) => {
              console.log('scroll log err: ', err);
          });
      });
      document.addEventListener(Event$1.selectionchange, throttle((event) => {
          const selection = document.getSelection();
          if (selection === null) {
              return;
          }
          if (isInputSelection()) {
              return;
          }
          const direction = detectSelectionDirection(selection);
          const selectionChangeLog = new LoggerSelection(TrackType.EVENT_SELECTIONCHANGE, event, selection, direction);
          console.log('selection change log: ', selectionChangeLog);
          iDBStoreInstance.set(OBJECTNAME, selectionChangeLog)
              .then(() => {
          })
              .catch((err) => {
              console.log('scroll log err: ', err);
          });
      }, 200));
  }
  //# sourceMappingURL=selection.js.map

  // Reference: https://rawgit.com/w3c/input-events/v1/index.html#interface-InputEvent-Attributes
  var InputType;
  (function (InputType) {
      InputType[InputType["insertText"] = 0] = "insertText";
      InputType[InputType["insertReplacementText"] = 1] = "insertReplacementText";
      InputType[InputType["insertLineBreak"] = 2] = "insertLineBreak";
      InputType[InputType["insertParagraph"] = 3] = "insertParagraph";
      InputType[InputType["insertOrderedList"] = 4] = "insertOrderedList";
      InputType[InputType["insertUnorderedList"] = 5] = "insertUnorderedList";
      InputType[InputType["insertHorizontalRule"] = 6] = "insertHorizontalRule";
      InputType[InputType["insertFromYank"] = 7] = "insertFromYank";
      InputType[InputType["insertFromDrop"] = 8] = "insertFromDrop";
      InputType[InputType["insertFromPaste"] = 9] = "insertFromPaste";
      InputType[InputType["insertFromPasteAsQuotation"] = 10] = "insertFromPasteAsQuotation";
      InputType[InputType["insertTranspose"] = 11] = "insertTranspose";
      InputType[InputType["insertCompositionText"] = 12] = "insertCompositionText";
      InputType[InputType["insertLink"] = 13] = "insertLink";
      InputType[InputType["deleteWordBackward"] = 14] = "deleteWordBackward";
      InputType[InputType["deleteWordForward"] = 15] = "deleteWordForward";
      InputType[InputType["deleteSoftLineBackward"] = 16] = "deleteSoftLineBackward";
      InputType[InputType["deleteSoftLineForward"] = 17] = "deleteSoftLineForward";
      InputType[InputType["deleteEntireSoftLine"] = 18] = "deleteEntireSoftLine";
      InputType[InputType["deleteHardLineBackward"] = 19] = "deleteHardLineBackward";
      InputType[InputType["deleteHardLineForward"] = 20] = "deleteHardLineForward";
      InputType[InputType["deleteByDrag"] = 21] = "deleteByDrag";
      InputType[InputType["deleteByCut"] = 22] = "deleteByCut";
      InputType[InputType["deleteContent"] = 23] = "deleteContent";
      InputType[InputType["deleteContentBackward"] = 24] = "deleteContentBackward";
      InputType[InputType["deleteContentForward"] = 25] = "deleteContentForward";
      InputType[InputType["historyUndo"] = 26] = "historyUndo";
      InputType[InputType["historyRedo"] = 27] = "historyRedo";
      InputType[InputType["formatBold"] = 28] = "formatBold";
      InputType[InputType["formatItalic"] = 29] = "formatItalic";
      InputType[InputType["formatUnderline"] = 30] = "formatUnderline";
      InputType[InputType["formatStrikeThrough"] = 31] = "formatStrikeThrough";
      InputType[InputType["formatSuperscript"] = 32] = "formatSuperscript";
      InputType[InputType["formatSubscript"] = 33] = "formatSubscript";
      InputType[InputType["formatJustifyFull"] = 34] = "formatJustifyFull";
      InputType[InputType["formatJustifyCenter"] = 35] = "formatJustifyCenter";
      InputType[InputType["formatJustifyRight"] = 36] = "formatJustifyRight";
      InputType[InputType["formatJustifyLeft"] = 37] = "formatJustifyLeft";
      InputType[InputType["formatIndent"] = 38] = "formatIndent";
      InputType[InputType["formatOutdent"] = 39] = "formatOutdent";
      InputType[InputType["formatRemove"] = 40] = "formatRemove";
      InputType[InputType["formatSetBlockTextDirection"] = 41] = "formatSetBlockTextDirection";
      InputType[InputType["formatSetInlineTextDirection"] = 42] = "formatSetInlineTextDirection";
      InputType[InputType["formatBackColor"] = 43] = "formatBackColor";
      InputType[InputType["formatFontColor"] = 44] = "formatFontColor";
      InputType[InputType["formatFontName"] = 45] = "formatFontName";
  })(InputType || (InputType = {}));
  //# sourceMappingURL=InputType.js.map

  class LoggerInputEvent extends LoggerUIEvent {
      constructor(TrackType, inputEvent) {
          super(TrackType, inputEvent);
          // this.inputType = inputEvent.inputType;
          this.inputType = InputType[inputEvent.inputType];
          this.isComposing = inputEvent.isComposing;
          this.isMasked = this.isMaskedInput(inputEvent);
          this.data = this.isMasked ? null : inputEvent.data;
          const value = inputEvent.target &&
              inputEvent.target.value || '';
          this.inputTargetValue = this.isMasked ? null : value;
          this.inputTargetValueLength = this.isMasked ? value.length : null;
      }
      isMaskedInput(inputEvent) {
          const { target } = inputEvent;
          const maskedInputTypes = ['email', 'number', 'password', 'search', 'tel', 'text', 'url'];
          if (target instanceof HTMLTextAreaElement ||
              (target instanceof HTMLInputElement && maskedInputTypes.includes(target.type))) {
              return true;
          }
          return false;
      }
  }
  //# sourceMappingURL=LoggerInputEvent.js.map

  function initInputListener() {
      window.addEventListener(Event$1.input, (event) => {
          // TODO range input type generate too many logs, optimize it
          const inputEvent = new LoggerInputEvent(TrackType.INPUTEVENT_INPUT, event);
          iDBStoreInstance.set(OBJECTNAME, inputEvent)
              .then(() => {
          })
              .catch((err) => {
              console.log('input log err: ', err);
          });
      });
  }
  //# sourceMappingURL=input.js.map

  let supportsConstructableEventTarget;
  try {
      // tslint:disable-next-line: no-unused-expression
      new EventTarget();
      supportsConstructableEventTarget = true;
  }
  catch (err) {
      supportsConstructableEventTarget = false;
  }
  //# sourceMappingURL=support.js.map

  class EventTargetShim {
      constructor() {
          this.registry = {};
      }
      /**
       * @see https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
       */
      addEventListener(type, listener) {
          this.getRegistry(type).push(listener);
      }
      /**
       * @see https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
       */
      removeEventListener(type, listener) {
          const typeRegistery = this.getRegistry(type);
          const handlerIndex = typeRegistery.indexOf(listener);
          if (handlerIndex > -1) {
              typeRegistery.splice(handlerIndex, 1);
          }
      }
      dispatchEvent(event) {
          // Set the target then freeze the event object to prevent modification.
          event.target = this;
          Object.freeze(event);
          this.getRegistry(event.type).forEach((listener) => {
              return listener(event);
          });
          return true;
      }
      /**
       * Returns an array of handlers associated with the passed event type.
       * If no handlers have been registered, an empty array is returned.
       * @private
       */
      getRegistry(type) {
          return this.registry[type] || [];
      }
  }
  var EventTarget$1 = supportsConstructableEventTarget ? EventTarget : EventTargetShim;
  //# sourceMappingURL=EventTarget.js.map

  /**
   * A minimal Event class shim.
   * This is used if the browser doesn't natively support constructable
   * EventTarget objects.
   */
  class EventShim {
      constructor(type) {
          this.type = type;
      }
  }
  var Event$2 = supportsConstructableEventTarget ? Event : EventShim;
  //# sourceMappingURL=Event.js.map

  class StateChangeEvent extends Event$2 {
      constructor(type, initDict) {
          super(type);
          this.newState = initDict.newState;
          this.prevState = initDict.prevState;
          this.originalEvent = initDict.originalEvent;
      }
  }
  //# sourceMappingURL=StateChangeEvent.js.map

  var PageState;
  (function (PageState) {
      PageState["ACTIVE"] = "active";
      PageState["PASSIVE"] = "passive";
      PageState["HIDDEN"] = "hidden";
      PageState["FROZEN"] = "frozen";
      // 'DISCARDED' = 'discarded', Not used but show to completeness.
      PageState["TERMINATED"] = "terminated";
  })(PageState || (PageState = {}));
  //# sourceMappingURL=PageState.js.map

  var PageEvent;
  (function (PageEvent) {
      PageEvent["focus"] = "focus";
      PageEvent["blur"] = "blur";
      PageEvent["visibilitychange"] = "visibilitychange";
      PageEvent["freeze"] = "freeze";
      PageEvent["resume"] = "resume";
      PageEvent["pageshow"] = "pageshow";
      PageEvent["pagehide"] = "pagehide";
      PageEvent["unload"] = "unload";
  })(PageEvent || (PageEvent = {}));
  //# sourceMappingURL=PageEvent.js.map

  const ACTIVE = PageState.ACTIVE;
  const PASSIVE = PageState.PASSIVE;
  const HIDDEN = PageState.HIDDEN;
  const FROZEN = PageState.FROZEN;
  // const DISCARDED = PageState.DISCARDED; Not used but show to completeness.
  const TERMINATED = PageState.TERMINATED;
  // Detect Safari to work around Safari-specific bugs.
  const safari = window.safari;
  const IS_SAFARI = typeof safari === 'object' && safari.pushNotification;
  const SUPPORTS_PAGE_TRANSITION_EVENTS = 'onpageshow' in self;
  const EVENTS = [
      PageEvent.focus,
      PageEvent.blur,
      PageEvent.visibilitychange,
      PageEvent.freeze,
      PageEvent.resume,
      PageEvent.pageshow,
      // IE9-10 do not support the pagehide event, so we fall back to unload
      // Note: unload *MUST ONLY* be added conditionally, otherwise it will
      // prevent page navigation caching (a.k.a bfcache).
      SUPPORTS_PAGE_TRANSITION_EVENTS ? PageEvent.pagehide : PageEvent.unload
  ];
  const onbeforeunload = (event) => {
      event.preventDefault();
      return event.returnValue = true;
  };
  /**
   * Converts an array of states into an object where the state is the key
   * and the value is the index.
   * @param arr {string[]} arr
   */
  const toIndexedObject = (arr) => {
      return arr.reduce((acc, curr, index) => {
          acc[curr] = index;
          return acc;
      }, {});
  };
  const LEGAL_STATE_TRANSITIONS = [
      // The normal unload process (bfcache process is addressed above).
      [ACTIVE, PASSIVE, HIDDEN, TERMINATED],
      // An active page transitioning to frozen,
      // or an unloading page going into the bfcache.
      [ACTIVE, PASSIVE, HIDDEN, FROZEN],
      // A hidden page transitioning back to active.
      [HIDDEN, PASSIVE, ACTIVE],
      // A frozen page being resumed
      [FROZEN, HIDDEN],
      // A frozen (bfcached) page navigated back to
      // Note: [FROZEN, HIDDEN] can happen here, but it's already covered above.
      [FROZEN, ACTIVE],
      [FROZEN, PASSIVE]
  ].map(toIndexedObject);
  /**
   * Accepts a current state and a future state and returns an array of legal
   * state transition paths. This is needed to normalize behavior across browsers
   * since some browsers do not fire events in certain cases and thus skip
   * states.
   * @param prevState string
   * @param currState string
   */
  const getLegalStateTransitionPath = (prevState, currState) => {
      for (let i = 0, len = LEGAL_STATE_TRANSITIONS.length; i < len; ++i) {
          const order = LEGAL_STATE_TRANSITIONS[i];
          const prevIndex = order[prevState];
          const currIndex = order[currState];
          if (prevIndex >= 0 &&
              currIndex >= 0 &&
              currIndex > prevIndex) {
              // Differences greater than one should be reported
              // because it means a state was skipped.
              return Object.keys(order).slice(prevIndex, currIndex + 1);
          }
      }
      return [];
  };
  /**
   * Returns the current state based on the document's visibility and
   * in input focus states. Note this method is only used to determine
   * active vs passive vs hidden states, as other states require listening
   * for events.
   * @return {string}
   */
  const getCurrentState = () => {
      if (document.visibilityState === HIDDEN) {
          return HIDDEN;
      }
      if (document.hasFocus()) {
          return ACTIVE;
      }
      return PASSIVE;
  };
  /**
   * Class definition for the exported, singleton lifecycle instance.
   */
  class Lifecycle extends EventTarget$1 {
      /**
       * Initializes state, state history, and adds event listeners to monitor
       * state changes.
       */
      constructor() {
          super();
          this.safariBeforeUnloadTimeout = undefined;
          this.handleEvents = (event) => {
              if (IS_SAFARI) {
                  window.clearTimeout(this.safariBeforeUnloadTimeout);
              }
              switch (event.type) {
                  case 'pageshow':
                  case 'resume':
                      this.dispatchChangesIfNeeded(event, getCurrentState());
                      break;
                  case 'focus':
                      this.dispatchChangesIfNeeded(event, ACTIVE);
                      break;
                  case 'blur':
                      // The `blur` event can fire while the page is being unloaded, so we
                      // only need to update the state if the current state is "active".
                      if (this.currState === ACTIVE) {
                          this.dispatchChangesIfNeeded(event, getCurrentState());
                      }
                      break;
                  case 'pagehide':
                  case 'unload':
                      this.dispatchChangesIfNeeded(event, event.persisted ? FROZEN : TERMINATED);
                      break;
                  case 'visibilitychange':
                      // The document's `visibilityState` will change to hidden as the page
                      // is being unloaded, but in such cases the lifecycle state shouldn't
                      // change.
                      if (this.currState !== FROZEN &&
                          this.currState !== TERMINATED) {
                          this.dispatchChangesIfNeeded(event, getCurrentState());
                      }
                      break;
                  case 'freeze':
                      this.dispatchChangesIfNeeded(event, FROZEN);
                      break;
              }
          };
          const state = getCurrentState();
          this.currState = state;
          this.unsavedChanges = [];
          EVENTS.forEach((event) => {
              return window.addEventListener(event, this.handleEvents, true);
          });
          // Safari does not reliably fire the `pagehide` or `visibilitychange`
          // events when closing a tab, so we have to use `beforeunload` with a
          // timeout to check whether the default action was prevented.
          // - https://bugs.webkit.org/show_bug.cgi?id=151610
          // - https://bugs.webkit.org/show_bug.cgi?id=151234
          // NOTE: we only add this to Safari because adding it to Firefox would
          // prevent the page from being eligible for bfcache.
          if (IS_SAFARI) {
              window.addEventListener('beforeunload', (event) => {
                  this.safariBeforeUnloadTimeout = window.setTimeout(() => {
                      if (!(event.defaultPrevented || event.returnValue)) {
                          this.dispatchChangesIfNeeded(event, HIDDEN);
                      }
                  }, 0);
              });
          }
      }
      get State() {
          return this.currState;
      }
      get pageWasDiscarded() {
          return document.wasDiscarded || false;
      }
      /**
       * @param id A unique symbol or object identifying the
       * pending state. This ID is required when removing the state later.
       */
      addUnsavedChanges(id) {
          if (!(this.unsavedChanges.indexOf(id) > -1)) {
              // If this is the first state being added,
              // also add a beforeunload listener.
              if (this.unsavedChanges.length === 0) {
                  window.addEventListener('beforeunload', onbeforeunload);
              }
              this.unsavedChanges.push(id);
          }
      }
      removeUnsavedChanges(id) {
          const idIndex = this.unsavedChanges.indexOf(id);
          if (idIndex > -1) {
              this.unsavedChanges.splice(idIndex, 1);
              // If there's no more pending state, remove the event listener.
              if (this.unsavedChanges.length === 0) {
                  window.removeEventListener('beforeunload', onbeforeunload);
              }
          }
      }
      dispatchChangesIfNeeded(originalEvent, newState) {
          if (newState !== this.currState) {
              const prevState = this.currState;
              const path = getLegalStateTransitionPath(prevState, newState);
              for (let i = 0, len = path.length; i < len - 1; ++i) {
                  // tslint:disable-next-line: no-shadowed-variable
                  const prevState = path[i];
                  // tslint:disable-next-line: no-shadowed-variable
                  const newState = path[i + 1];
                  this.currState = newState;
                  this.dispatchEvent(new StateChangeEvent('statechange', {
                      prevState,
                      newState,
                      originalEvent
                  }));
              }
          }
      }
  }
  //# sourceMappingURL=Lifecycle.js.map

  var lifecycle = new Lifecycle();
  //# sourceMappingURL=index.js.map

  class LoggerStateChangeEvent extends LoggerEvent {
      constructor(TrackType, stateChangeEvent) {
          super(TrackType, stateChangeEvent);
          this.newState = stateChangeEvent.newState;
          this.prevState = stateChangeEvent.prevState;
      }
  }
  //# sourceMappingURL=LoggerStateChangeEvent.js.map

  function initStateChangeListener() {
      lifecycle.addEventListener(CustomEvent.statechange, (event) => {
          const statechangeLogger = new LoggerStateChangeEvent(TrackType.STATECHANGE, event);
          console.log('STATECHANGE LOG: ', statechangeLogger);
          iDBStoreInstance.set(OBJECTNAME, statechangeLogger)
              .then(() => {
              // console.log('statechange log added');
          })
              .catch((err) => {
              console.log('statechange log err: ', err);
          });
          const newState = statechangeLogger.newState;
          if (newState === PageState.TERMINATED) {
              iDBStoreInstance.deleteDataBase(DBNAME);
          }
      });
  }

  window.addEventListener('DOMContentLoaded', () => {
      const [node, idNodeMap] = snapshot(document);
      console.log('node: ', JSON.stringify(node));
      console.log('idNodeMap: ', idNodeMap);
      nodeMirror.map = idNodeMap;
      pageSize.setPageSize(document.defaultView.innerWidth, document.defaultView.innerHeight);
      pageScroll.setPageScroll(window.scrollX, window.scrollY);
      initMutationObserver();
      initResizeListener();
      initScrollListener();
      initMouseListener();
      initSelectionListener();
      initInputListener();
      initStateChangeListener();
  });
  //# sourceMappingURL=index.js.map

  //# sourceMappingURL=index.js.map

}());
