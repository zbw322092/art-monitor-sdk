(function () {
  'use strict';

  const RANDOM = Math.random().toString(36).substr(2, 9) + '_' + Date.now();
  //# sourceMappingURL=RANDOM.js.map

  window.TRACKID = RANDOM;
  //# sourceMappingURL=TRACKID.js.map

  const COMPLETED_READY_STATE = 4;
  const NativeXHRSend = XMLHttpRequest.prototype.send;
  const requestCallbacks = [];
  const responseCallbacks = [];
  let wired = false;
  const arrayRemove = (array, item) => {
      const index = array.indexOf(item);
      if (index > -1) {
          array.splice(index, 1);
      }
      else {
          throw new Error('Could not remove ' + item + ' from array');
      }
  };
  const fireCallbacks = (callbacks, xhr) => {
      for (let i = 0, len = callbacks.length; i < len; i++) {
          callbacks[i](xhr);
      }
  };
  const fireResponseCallbacksIfCompleted = (xhr) => {
      if (xhr.readyState === COMPLETED_READY_STATE) {
          fireCallbacks(responseCallbacks, xhr);
      }
  };
  const proxifyOnReadyStateChange = (xhr) => {
      const realOnReadyStateChange = xhr.onreadystatechange;
      if (realOnReadyStateChange) {
          xhr.onreadystatechange = function () {
              fireResponseCallbacksIfCompleted(xhr);
              realOnReadyStateChange();
          };
      }
  };
  const xhrInterceptor = {
      addRequestCallback: (callback) => {
          requestCallbacks.push(callback);
      },
      removeRequestCallback: (callback) => {
          arrayRemove(requestCallbacks, callback);
      },
      addResponseCallback: (callback) => {
          responseCallbacks.push(callback);
      },
      removeResponseCallback: (callback) => {
          arrayRemove(responseCallbacks, callback);
      },
      isWired: () => {
          return wired;
      },
      wire: () => {
          // XHR interceptor already wired
          if (wired) {
              return;
          }
          // Override send method of all XHR requests
          XMLHttpRequest.prototype.send = function () {
              // Fire request callbacks before sending the request
              fireCallbacks(requestCallbacks, this);
              // Wire response callbacks
              if (this.addEventListener) {
                  const self = this;
                  this.addEventListener('readystatechange', function () {
                      fireResponseCallbacksIfCompleted(self);
                  }, false);
              }
              else {
                  proxifyOnReadyStateChange(this);
              }
              NativeXHRSend.apply(this, arguments);
          };
          wired = true;
      },
      unwire: () => {
          // XHR interceptor not currently wired
          if (!wired) {
              return;
          }
          XMLHttpRequest.prototype.send = NativeXHRSend;
          wired = false;
      }
  };
  //# sourceMappingURL=xhr-interceptor.js.map

  class LoggerBase {
      constructor(TrackType) {
          this.timestamp = performance.now();
          this.trackId = window.TRACKID;
          this.TrackType = TrackType;
      }
  }
  //# sourceMappingURL=LoggerBase.js.map

  const handleXHRResponse = (xhr) => {
      let response;
      switch (xhr.responseType) {
          case '':
          case 'text':
              response = xhr.response;
              break;
          case 'json':
              response = JSON.stringify(xhr.response);
              break;
          default:
              response = Object.prototype.toString.call(xhr.response);
              break;
      }
      return response;
  };
  class LoggerXHR extends LoggerBase {
      constructor(TrackType, xhr) {
          super(TrackType);
          this.responseURL = xhr.responseURL;
          this.status = xhr.status;
          this.statusText = xhr.statusText;
          this.responseType = xhr.responseType;
          this.response = handleXHRResponse(xhr);
          this.readyState = xhr.readyState;
          this.timeout = xhr.timeout;
      }
  }
  //# sourceMappingURL=LoggerXHR.js.map

  var TrackType;
  (function (TrackType) {
      TrackType["EVENT"] = "event";
      TrackType["KEYBOARDEVENT"] = "keyboardEvent";
      TrackType["MOUSEEVENT"] = "mouseEvent";
      TrackType["TOUCHEVENT"] = "touchEvent";
      TrackType["STATECHANGE"] = "statechange";
      TrackType["MUTATION"] = "mutation";
      TrackType["XHRINTERCEPT"] = "XHRIntercept";
      TrackType["ERROR"] = "error";
  })(TrackType || (TrackType = {}));
  //# sourceMappingURL=TrackType.js.map

  // import { Cursor } from './Cursor';
  const promisifyRequest = (request) => {
      return new Promise((resolve, reject) => {
          request.onsuccess = () => {
              resolve(request.result);
          };
          request.onerror = () => {
              reject(request.error);
          };
      });
  };
  const promisifyRequestCall = (obj, method, args) => {
      let request;
      const promiseCall = new Promise((resolve, reject) => {
          request = obj[method].apply(obj, args);
          if (request) {
              promisifyRequest(request).then(resolve, reject);
          }
      });
      promiseCall.request = request;
      return promiseCall;
  };
  const promisifyCursorRequestCall = (obj, method, args, Cursor) => {
      const promiseCall = promisifyRequestCall(obj, method, args);
      return promiseCall.then((value) => {
          if (!value) {
              return;
          }
          return new Cursor(value, promiseCall.request);
      });
  };
  //# sourceMappingURL=promisifyRequest.js.map

  const proxyProperties = (ProxyClass, targetProp, properties) => {
      properties.forEach((prop) => {
          Object.defineProperty(ProxyClass.prototype, prop, {
              get() {
                  return this[targetProp][prop];
              },
              set(val) {
                  return this[targetProp][prop] = val;
              }
          });
      });
  };
  const proxyRequestMethods = (ProxyClass, targetProp, Constructor, properties) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return promisifyRequestCall(this[targetProp], prop, arguments);
          };
      });
  };
  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return this[targetProp][prop].apply(this[targetProp], arguments);
          };
      });
  }
  const proxyCursorRequestMethods = (ProxyClass, targetProp, Constructor, properties, Cursor) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype))
              return;
          ProxyClass.prototype[prop] = function () {
              return promisifyCursorRequestCall(this[targetProp], prop, arguments, Cursor);
          };
      });
  };
  //# sourceMappingURL=proxies.js.map

  function Cursor(cursor, request) {
      this._cursor = cursor;
      this._request = request;
  }
  proxyProperties(Cursor, '_cursor', [
      'direction',
      'key',
      'primaryKey',
      'value'
  ]);
  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
      'update',
      'delete'
  ]);
  //# sourceMappingURL=Cursor.js.map

  function Index(index) {
      this._index = index;
  }
  proxyProperties(Index, '_index', [
      'name',
      'keyPath',
      'multiEntry',
      'unique'
  ]);
  proxyRequestMethods(Index, '_index', IDBIndex, [
      'get',
      'getKey',
      'getAll',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  //# sourceMappingURL=DBIndex.js.map

  function ObjectStore(store) {
      this._store = store;
  }
  ObjectStore.prototype.createIndex = function () {
      return new Index(this._store.createIndex.apply(this._store, arguments));
  };
  ObjectStore.prototype.index = function () {
      return new Index(this._store.index.apply(this._store, arguments));
  };
  proxyProperties(ObjectStore, '_store', [
      'name',
      'keyPath',
      'indexNames',
      'autoIncrement'
  ]);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'put',
      'add',
      'delete',
      'clear',
      'get',
      'getAll',
      'getKey',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'deleteIndex'
  ]);
  //# sourceMappingURL=ObjectStore.js.map

  function Transaction(idbTransaction) {
      this._tx = idbTransaction;
      this.complete = new Promise((resolve, reject) => {
          idbTransaction.oncomplete = () => {
              resolve();
          };
          idbTransaction.onerror = () => {
              reject(idbTransaction.error);
          };
          idbTransaction.onabort = () => {
              reject(idbTransaction.error);
          };
      });
  }
  Transaction.prototype.objectStore = function () {
      return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };
  proxyProperties(Transaction, '_tx', [
      'objectStoreNames',
      'mode'
  ]);
  proxyMethods(Transaction, '_tx', IDBTransaction, [
      'abort'
  ]);
  //# sourceMappingURL=Transaction.js.map

  function UpgradeDB(db, oldVersion, transaction) {
      this._db = db;
      this.oldVersion = oldVersion;
      this.transaction = transaction ? new Transaction(transaction) : null;
  }
  UpgradeDB.prototype.createObjectStore = function () {
      return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };
  proxyProperties(UpgradeDB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
      'deleteObjectStore',
      'close'
  ]);
  //# sourceMappingURL=UpgradeDB.js.map

  function DB(db) {
      this._db = db;
  }
  proxyProperties(DB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(DB, '_db', IDBDatabase, [
      'close'
  ]);
  DB.prototype.transaction = function () {
      return new Transaction(this._db.transaction.apply(this._db, arguments));
  };
  //# sourceMappingURL=db.js.map

  function toArray(arr) {
      return Array.prototype.slice.call(arr);
  }
  ['advance', 'continue', 'continuePrimaryKey'].forEach((methodName) => {
      if (!(methodName in IDBCursor.prototype)) {
          return;
      }
      Cursor.prototype[methodName] = function () {
          const cursor = this;
          const args = arguments;
          return Promise.resolve().then(() => {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then((value) => {
                  if (!value) {
                      return;
                  }
                  return new Cursor(value, cursor._request);
              });
          });
      };
  });
  // Add cursor iterators
  ['openCursor', 'openKeyCursor'].forEach((funcName) => {
      [ObjectStore, Index].forEach((Constructor) => {
          // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
          if (!(funcName in Constructor.prototype)) {
              return;
          }
          Constructor.prototype[funcName.replace('open', 'iterate')] = function () {
              const args = toArray(arguments);
              const callback = args[args.length - 1];
              const nativeObject = this._store || this._index;
              const request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
              request.onsuccess = () => {
                  callback(request.result);
              };
          };
      });
  });
  // polyfill getAll
  [Index, ObjectStore].forEach((Constructor) => {
      if (Constructor.prototype.getAll)
          return;
      Constructor.prototype.getAll = function (query, count) {
          const instance = this;
          const items = [];
          return new Promise((resolve) => {
              instance.iterateCursor(query, (cursor) => {
                  if (!cursor) {
                      resolve(items);
                      return;
                  }
                  items.push(cursor.value);
                  if (count !== undefined && items.length === count) {
                      resolve(items);
                      return;
                  }
                  cursor.continue();
              });
          });
      };
  });
  const idb = {
      open: (name, version, upgradeCallback) => {
          const promiseWithReq = promisifyRequestCall(indexedDB, 'open', [name, version]);
          const request = promiseWithReq.request;
          if (request) {
              request.onupgradeneeded = (event) => {
                  if (upgradeCallback) {
                      upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
                  }
              };
          }
          return promiseWithReq.then((db) => {
              return new DB(db);
          });
      },
      delete: (name) => {
          return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
      }
  };
  //# sourceMappingURL=idb.js.map

  //# sourceMappingURL=index.js.map

  const DBNAME = 'QNN-MKT';
  const DBVERSION = 1;
  const OBJECTNAME = 'ERROR-REPORTING';
  const KETPATH = 'id';
  const CLEARINTERVAL = 10000;
  const CLEARRANGELOW = 20000;
  const CLEARRANGEHIGH = 10000;
  const OFFSET = 20;
  //# sourceMappingURL=DB.js.map

  class IDBStore {
      constructor(dbName, upgradeCallback) {
          this.get = (objName, key) => {
              return this.dbPromise.then((db) => {
                  return db.transaction(objName)
                      .objectStore(objName).get(key);
              });
          };
          this.set = (objName, val) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).put(val);
                  return tx.complete;
              });
          };
          this.delete = (objName, key) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).delete(key);
                  return tx.complete;
              });
          };
          this.clear = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).clear();
                  return tx.complete;
              });
          };
          this.getDBPromise = () => {
              return this.dbPromise;
          };
          this.keys = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName);
                  const keys = [];
                  const store = tx.objectStore(objName);
                  // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.
                  // openKeyCursor isn't supported by Safari, so we fall back
                  (store.iterateKeyCursor || store.iterateCursor).call(store, (cursor) => {
                      if (!cursor) {
                          return;
                      }
                      keys.push(cursor.key);
                      cursor.continue();
                  });
                  return tx.complete.then(() => {
                      return keys;
                  });
              });
          };
          this.dbPromise = idb.open(dbName, DBVERSION, upgradeCallback);
      }
      deleteDataBase(dbName) {
          return idb.delete(dbName)
              .then(() => {
              console.log(`delete ${dbName} database successfully`);
          })
              .catch((err) => {
              console.log(`delete ${dbName} database err: `, err);
          });
      }
  }
  const iDBStoreInstance = new IDBStore(DBNAME, (upgradeDB) => {
      if (!upgradeDB.objectStoreNames.contains(OBJECTNAME)) {
          const objectStore = upgradeDB.createObjectStore(OBJECTNAME, { keyPath: KETPATH, autoIncrement: true });
          objectStore.createIndex('timestamp', 'timestamp');
      }
  });
  //# sourceMappingURL=IDBStore.js.map

  xhrInterceptor.addResponseCallback((xhr) => {
      const xhrLogger = new LoggerXHR(TrackType.XHRINTERCEPT, xhr);
      console.log('xhr log: ', xhrLogger);
      iDBStoreInstance.set(OBJECTNAME, xhrLogger)
          .then(() => {
          console.log('xhr log added');
      })
          .catch((err) => {
          console.log('xhr log err: ', err);
      });
  });
  xhrInterceptor.wire();
  //# sourceMappingURL=xhrInterceptor.js.map

  //# sourceMappingURL=index.js.map

  const perf = performance.getEntries();
  //# sourceMappingURL=performance.js.map

  //# sourceMappingURL=index.js.map

  window.setInterval(() => {
      const now = performance.now();
      const range = IDBKeyRange.bound(now - CLEARRANGELOW - OFFSET, now - CLEARRANGEHIGH + OFFSET);
      let count = 0;
      let minIndex, maxIndex;
      iDBStoreInstance.getDBPromise()
          .then((db) => {
          const transaction = db.transaction(OBJECTNAME);
          const store = transaction.objectStore(OBJECTNAME);
          const index = store.index('timestamp');
          return index.openCursor(range);
      }).then(function showRange(cursor) {
          if (!cursor) {
              return;
          }
          const primaryKey = cursor.primaryKey;
          if (minIndex === undefined) {
              minIndex = primaryKey;
          }
          if (maxIndex === undefined) {
              maxIndex = primaryKey;
          }
          minIndex = primaryKey < minIndex ? primaryKey : minIndex;
          maxIndex = primaryKey > maxIndex ? primaryKey : maxIndex;
          count++;
          return cursor.continue().then(showRange);
      }).then(function () {
          if (minIndex === maxIndex) {
              console.log('no new records');
              return;
          }
          iDBStoreInstance.delete(OBJECTNAME, IDBKeyRange.bound(minIndex, maxIndex))
              .then(() => {
              console.log(`${count} records deleted`);
          })
              .catch((err) => {
              console.log(`delete record has err: `, err);
          });
      });
  }, CLEARINTERVAL);
  //# sourceMappingURL=intervalClear.js.map

  const getBehaviorRecords = () => {
      const now = performance.now();
      const range = IDBKeyRange.bound(now - CLEARINTERVAL, now);
      let count = 0;
      let minIndex, maxIndex;
      let store;
      return iDBStoreInstance.getDBPromise()
          .then((db) => {
          const transaction = db.transaction(OBJECTNAME);
          store = transaction.objectStore(OBJECTNAME);
          const index = store.index('timestamp');
          return index.openCursor(range);
      }).then(function showRange(cursor) {
          if (!cursor) {
              return;
          }
          const primaryKey = cursor.primaryKey;
          if (minIndex === undefined) {
              minIndex = primaryKey;
          }
          if (maxIndex === undefined) {
              maxIndex = primaryKey;
          }
          minIndex = primaryKey < minIndex ? primaryKey : minIndex;
          maxIndex = primaryKey > maxIndex ? primaryKey : maxIndex;
          count++;
          return cursor.continue().then(showRange);
      }).then(function () {
          if (minIndex === maxIndex) {
              console.log('no new records');
              return;
          }
          return store.getAll(IDBKeyRange.bound(minIndex, maxIndex))
              .then((records) => {
              console.log(`got ${count} records`);
              return records;
          })
              .catch((err) => {
              return err;
          });
      });
  };
  //# sourceMappingURL=getBehaviorRecords.js.map

  /**
   * Determines whether the passed element is a DOM element
   * see: https://developer.mozilla.org/en-US/docs/Web/API/Element
   */
  const isElement = (element) => {
      let isElem;
      if (typeof Element === 'function') {
          isElem = element instanceof Element;
      }
      else {
          isElem = !!element && typeof element === 'object' &&
              element.nodeType === 1 && typeof element.nodeName === 'string';
      }
      return isElem;
  };
  //# sourceMappingURL=isElement.js.map

  const getParents = (element) => {
      const parents = [];
      let currentElement = element;
      while (isElement(currentElement)) {
          parents.push(currentElement);
          currentElement = currentElement.parentElement;
      }
      return parents;
  };
  //# sourceMappingURL=getParents.js.map

  /**
   * Return the tag name of the element
   * @param {Element} element
   */
  const getTag = (element) => {
      // Element.tagName
      return element.tagName.toLowerCase().replace(/:/g, '\\:');
  };
  //# sourceMappingURL=getTag.js.map

  /**
   * Returns the selectors based on the position of the element relative to its siblings
   * @param {Element} element
   */
  const getNthChild = (element) => {
      let counter = 0;
      const { parentElement } = element;
      if (parentElement) {
          /**
           *  NodeList and HTMLCollection both interfaces are collections of DOM nodes.
           * They differ in the methods they provide and in the type of nodes they can
           * contain. While a NodeList can contain any node type, an HTMLCollection
           * is supposed to only contain Element nodes.
           *
           * The ParentNode property children is a read-only property that returns a live
           * HTMLCollection which contains all of the child elements of the node upon which
           * it was called.
           * https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children
           */
          const { children } = parentElement;
          const len = children.length;
          for (let k = 0; k < len; k++) {
              const sibling = children[k];
              counter++;
              if (sibling === element) {
                  return `:nth-child(${counter})`;
              }
          }
      }
      return null;
  };
  //# sourceMappingURL=getNthChild.js.map

  /**
   * Returns the Attribute selectors of the element
   * @param element
   * @param attributesToIgnore
   */
  const getAttributes = (element, attributesToIgnore = ['id', 'class', 'length']) => {
      const { attributes } = element;
      if (attributes === null) {
          return null;
      }
      const acc = [];
      Array.prototype.forEach.call(attributes, (attr) => {
          if (!(attributesToIgnore.indexOf(attr.nodeName) > -1)) {
              acc.push(`[${attr.nodeName}="${attr.nodeValue}"]`);
          }
      });
      return acc.join('');
  };
  //# sourceMappingURL=getAttributes.js.map

  /**
   * Get class names for an element
   * @param element
   */
  const getClasses = (element) => {
      if (!element.hasAttribute('class')) {
          return null;
      }
      try {
          // Element.classList support from IE 10
          const classList = Array.prototype.slice.call(element.classList);
          // return only the valid CSS selectors based on RegEx
          return classList.filter((item) => {
              return /^[a-z_-][a-z\d_-]*$/i.test(item);
          }).map((className) => {
              return `.${className}`;
          }).join('');
      }
      catch (err) {
          let classNames = element.getAttribute('class');
          classNames = classNames.trim().replace(/\s+/g, ' ');
          return classNames.split(' ').map((className) => {
              return `.${className}`;
          }).join('');
      }
  };
  //# sourceMappingURL=getClasses.js.map

  /**
   * Return the id attribute of the element
   * @param {Element} element
   */
  const getID = (element) => {
      // Element.getAttribute()
      const id = element.getAttribute('id');
      if (id !== null && id !== '') {
          // if the ID starts with a number selecting with a hash will cause a DOMException
          return id.match(/^\d/) ? `[id="${id}"]` : '#' + id;
      }
      return null;
  };
  //# sourceMappingURL=getID.js.map

  /**
   * Checks if the selector is unique
   * @param element
   * @param selector
   */
  const isUnique = (element, selector) => {
      if (!selector) {
          return false;
      }
      const doc = element.ownerDocument;
      if (doc === null) {
          return false;
      }
      const elems = doc.querySelectorAll(selector);
      return elems.length === 1 && elems[0] === element;
  };
  //# sourceMappingURL=isUnique.js.map

  const getUniqueSelector = (element, attributesToIgnore) => {
      const id = getID(element);
      if (id) {
          return id;
      }
      const classes = getClasses(element);
      if (classes && isUnique(element, classes)) {
          return classes;
      }
      const attrs = getAttributes(element, attributesToIgnore);
      if (attrs && isUnique(element, attrs)) {
          return attrs;
      }
      if (classes && attrs && isUnique(element, classes + attrs)) {
          return classes + attrs;
      }
      const tag = getTag(element);
      if (isUnique(element, tag)) {
          return tag;
      }
      if (classes && attrs && isUnique(element, classes + attrs + ' ' + tag)) {
          return classes + attrs + ' ' + tag;
      }
      return null;
  };
  const unique = (element, options = {}) => {
      const { attributesToIgnore = ['id', 'class', 'length'] } = options;
      const parents = getParents(element);
      let uniqueSelector = '';
      let firstUniqueElem;
      let firstUniqueElemIndex = -1;
      for (const elem of parents) {
          const selector = getUniqueSelector(elem, attributesToIgnore);
          firstUniqueElemIndex++;
          if (selector) {
              firstUniqueElem = elem;
              uniqueSelector = selector;
              break;
          }
      }
      if (firstUniqueElem === element) {
          return uniqueSelector;
      }
      const elementPath = parents.slice(0, firstUniqueElemIndex);
      elementPath.forEach((elem) => {
          uniqueSelector = uniqueSelector + ' ' + getTag(elem) + getNthChild(elem);
      });
      return uniqueSelector;
  };
  //# sourceMappingURL=index.js.map

  const getEventTargetInfo = (eventTarget) => {
      if (eventTarget === null) {
          return null;
      }
      else if (eventTarget instanceof Element) {
          return unique(eventTarget);
      }
      else {
          return Object.prototype.toString.call(eventTarget);
      }
  };
  //# sourceMappingURL=getEventTargetInfo.js.map

  class LoggerEvent extends LoggerBase {
      constructor(TrackType, event) {
          super(TrackType);
          this.type = event.type;
          this.eventPhase = event.eventPhase;
          this.currentTarget = getEventTargetInfo(event.currentTarget);
          this.target = getEventTargetInfo(event.target);
      }
  }
  //# sourceMappingURL=LoggerEvent.js.map

  class LoggerError extends LoggerEvent {
      constructor(TrackType, errorEvent) {
          super(TrackType, errorEvent);
          this.message = errorEvent.message;
          this.filename = errorEvent.filename;
          this.lineno = errorEvent.lineno;
          this.colno = errorEvent.colno;
          this.error = JSON.stringify(errorEvent.error);
      }
  }
  //# sourceMappingURL=LoggerError.js.map

  var HttpMethod;
  (function (HttpMethod) {
      HttpMethod["GET"] = "GET";
      HttpMethod["POST"] = "POST";
      HttpMethod["PUT"] = "PUT";
      HttpMethod["DELETE"] = "DELETE";
      HttpMethod["HEAD"] = "HEAD";
      HttpMethod["OPTIONS"] = "OPTIONS";
  })(HttpMethod || (HttpMethod = {}));
  //# sourceMappingURL=HttpMethod.js.map

  var ReadyState;
  (function (ReadyState) {
      ReadyState[ReadyState["UNSENT"] = 0] = "UNSENT";
      ReadyState[ReadyState["OPENED"] = 1] = "OPENED";
      ReadyState[ReadyState["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
      ReadyState[ReadyState["LOADING"] = 3] = "LOADING";
      ReadyState[ReadyState["DONE"] = 4] = "DONE";
  })(ReadyState || (ReadyState = {}));
  //# sourceMappingURL=ReadyState.js.map

  function XHR(url, options, callback) {
      let xhr = options.xhr || null;
      const nativeXMLHttpRequest = XMLHttpRequest || noop;
      const nativeXDomainRequest = 'withCredentials' in (new nativeXMLHttpRequest()) ?
          XMLHttpRequest : window.XDomainRequest;
      const { headers = {}, method = HttpMethod.GET, username, password, withCredentials, timeout, responseType, beforeSend, useXDR, json } = options;
      let body = options.body;
      const sync = !!options.sync;
      let aborted = false;
      let timeoutTimer;
      const failureResponse = {
          body: {},
          headers: {},
          statusCode: 0,
          method,
          url,
          rawRequest: xhr
      };
      if (xhr === null) {
          if (useXDR) {
              xhr = new nativeXDomainRequest();
          }
          else {
              xhr = new nativeXMLHttpRequest();
          }
      }
      if (json === true) {
          if (headers.accept || headers.Accept) {
              headers.Accept = 'application/json';
          }
          if (method !== HttpMethod.GET && method !== HttpMethod.HEAD) {
              if (headers['content-type'] || headers['Content-Type']) {
                  headers['Content-Type'] = 'application/json';
              }
              body = JSON.stringify(body);
          }
      }
      let called = false;
      const callbackOnce = function (err, response, cbBody) {
          if (!called) {
              called = true;
              callback(err, response, cbBody);
          }
      };
      function getBody() {
          // Chrome with requestType=blob throws errors arround when even testing access to responseText
          let responseBody;
          if (xhr.response) {
              responseBody = xhr.response;
          }
          else {
              responseBody = xhr.responseText || getXml(xhr);
          }
          if (json) {
              try {
                  responseBody = JSON.parse(responseBody);
              }
              catch (err) {
                  console.log('JSON parse error: ', err);
              }
          }
          return responseBody;
      }
      function onLoad() {
          if (aborted) {
              return;
          }
          let status;
          let response = failureResponse;
          let err;
          clearTimeout(timeoutTimer);
          if (useXDR && xhr.status === undefined) {
              // IE8 CORS GET successful response doesn't have a status field, but body is fine
              status = 200;
          }
          else {
              status = xhr.status === 1223 ? 204 : xhr.status;
          }
          if (status !== 0) {
              response = {
                  body: getBody(),
                  statusCode: status,
                  method,
                  headers: {},
                  url,
                  rawRequest: xhr
              };
              if (xhr.getAllResponseHeaders) {
                  // xhr can in fact be XDR for CORS in IE
                  response.headers = parseHeaders(xhr.getAllResponseHeaders());
              }
          }
          else {
              err = new Error('Internal XMLHttpRequest Error');
          }
          return callbackOnce(err, response, response.body);
      }
      function onError(err) {
          clearTimeout(timeoutTimer);
          if (!(err instanceof Error)) {
              err = new Error('' + (err || 'Unknown XMLHttpRequest Error'));
          }
          err.statusCode = 0;
          return callbackOnce(err, failureResponse, failureResponse.body);
      }
      xhr.onreadystatechange = () => {
          if (xhr.readyState === ReadyState.DONE) {
              setTimeout(onLoad, 0);
          }
      };
      xhr.onload = onLoad;
      xhr.onerror = onError;
      // IE9 must have onprogress be set to a unique function.
      // tslint:disable-next-line:no-empty
      xhr.onprogress = () => { };
      xhr.onabort = () => {
          aborted = true;
      };
      xhr.ontimeout = onError;
      xhr.open(method, url, !sync, username, password);
      if (!sync) {
          xhr.withCredentials = !!withCredentials;
      }
      // Cannot set timeout with sync request
      // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
      // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
      if (!sync && timeout && timeout > 0) {
          timeoutTimer = setTimeout(() => {
              if (aborted) {
                  return;
              }
              aborted = true; // IE9 may still call readystatechange
              xhr.abort();
              const err = new Error('XMLHttpRequest timeout');
              err.code = 'ETIMEDOUT';
              onError(err);
          }, timeout);
      }
      if (xhr.setRequestHeader) {
          for (const key in headers) {
              if (headers.hasOwnProperty(key)) {
                  xhr.setRequestHeader(key, headers[key]);
              }
          }
      }
      else if (headers && isEmpty(headers)) {
          throw new Error('Headers cannot be set on an XDomainRequest object');
      }
      if (responseType) {
          xhr.responseType = responseType;
      }
      if (beforeSend && typeof options.beforeSend === 'function') {
          beforeSend(xhr);
      }
      // Microsoft Edge browser sends "undefined" when send is called with undefined value.
      // XMLHttpRequest spec says to pass null as body to indicate no body
      // See https://github.com/naugtur/xhr/issues/100.
      xhr.send(body || null);
      return xhr;
  }
  // tslint:disable-next-line:no-empty
  function noop() { }
  function isEmpty(obj) {
      for (const index in obj) {
          if (obj.hasOwnProperty(index)) {
              return false;
          }
      }
      return true;
  }
  function getXml(xhr) {
      // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
      // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
      try {
          if (xhr.responseType === 'document') {
              return xhr.responseXML;
          }
          const firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === 'parsererror';
          if (xhr.responseType === '' && !firefoxBugTakenEffect) {
              return xhr.responseXML;
          }
      }
      catch (err) {
          console.log('getXml: ', err);
      }
      return null;
  }
  function isArray(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
  }
  function parseHeaders(headers) {
      if (!headers) {
          return {};
      }
      const result = {};
      headers.trim().split('\n').forEach((row) => {
          const index = row.indexOf(':'), key = row.slice(0, index).trim().toLowerCase(), value = row.slice(index + 1).trim();
          if (typeof (result[key]) === 'undefined') {
              result[key] = value;
          }
          else if (isArray(result[key])) {
              result[key].push(value);
          }
          else {
              result[key] = [result[key], value];
          }
      });
      return result;
  }
  //# sourceMappingURL=index.js.map

  const BASEURL = 'http://me.dev.com:9091';
  const REQUESTPATH = '/logging';
  //# sourceMappingURL=API.js.map

  class LoggerBasicInfo {
      constructor() {
          this.trackId = window.TRACKID;
          this.location = {
              href: window.location.href,
              host: window.location.host,
              hostname: window.location.hostname,
              protocol: window.location.protocol,
              origin: window.location.origin,
              port: window.location.port,
              pathname: window.location.pathname,
              hash: window.location.hash,
              search: window.location.search
          };
      }
  }
  //# sourceMappingURL=LoggerBasicInfo.js.map

  window.addEventListener('error', (error) => {
      getBehaviorRecords()
          .then((records) => {
          console.log('records within error happened 10s: ', records);
          const errorTrackInfo = {
              info: new LoggerBasicInfo(),
              track: {
                  error: new LoggerError(TrackType.ERROR, error),
                  behaviors: records
              }
          };
          XHR(BASEURL + REQUESTPATH, {
              method: HttpMethod.POST,
              body: JSON.stringify(errorTrackInfo)
          }, (err, response) => {
              if (err) {
                  console.log('error report error: ', err);
                  return;
              }
              console.log('error report response: ', response);
          });
      })
          .catch((err) => {
          console.log(`get record has err: `, err);
      });
  });
  //# sourceMappingURL=errorListener.js.map

  var EventType;
  (function (EventType) {
      EventType[EventType["DomContentLoaded"] = 0] = "DomContentLoaded";
      EventType[EventType["Load"] = 1] = "Load";
      EventType[EventType["FullSnapshot"] = 2] = "FullSnapshot";
      EventType[EventType["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
      EventType[EventType["Meta"] = 4] = "Meta";
      EventType[EventType["Custom"] = 5] = "Custom";
  })(EventType || (EventType = {}));
  var IncrementalSource;
  (function (IncrementalSource) {
      IncrementalSource[IncrementalSource["Mutation"] = 0] = "Mutation";
      IncrementalSource[IncrementalSource["MouseMove"] = 1] = "MouseMove";
      IncrementalSource[IncrementalSource["MouseInteraction"] = 2] = "MouseInteraction";
      IncrementalSource[IncrementalSource["Scroll"] = 3] = "Scroll";
      IncrementalSource[IncrementalSource["ViewportResize"] = 4] = "ViewportResize";
      IncrementalSource[IncrementalSource["Input"] = 5] = "Input";
      IncrementalSource[IncrementalSource["TouchMove"] = 6] = "TouchMove";
  })(IncrementalSource || (IncrementalSource = {}));
  var MouseInteractions;
  (function (MouseInteractions) {
      MouseInteractions[MouseInteractions["MouseUp"] = 0] = "MouseUp";
      MouseInteractions[MouseInteractions["MouseDown"] = 1] = "MouseDown";
      MouseInteractions[MouseInteractions["Click"] = 2] = "Click";
      MouseInteractions[MouseInteractions["ContextMenu"] = 3] = "ContextMenu";
      MouseInteractions[MouseInteractions["DblClick"] = 4] = "DblClick";
      MouseInteractions[MouseInteractions["Focus"] = 5] = "Focus";
      MouseInteractions[MouseInteractions["Blur"] = 6] = "Blur";
      MouseInteractions[MouseInteractions["TouchStart"] = 7] = "TouchStart";
      MouseInteractions[MouseInteractions["TouchMove_Departed"] = 8] = "TouchMove_Departed";
      MouseInteractions[MouseInteractions["TouchEnd"] = 9] = "TouchEnd";
  })(MouseInteractions || (MouseInteractions = {}));
  var ReplayerEvents;
  (function (ReplayerEvents) {
      ReplayerEvents["Start"] = "start";
      ReplayerEvents["Pause"] = "pause";
      ReplayerEvents["Resume"] = "resume";
      ReplayerEvents["Resize"] = "resize";
      ReplayerEvents["Finish"] = "finish";
      ReplayerEvents["FullsnapshotRebuilded"] = "fullsnapshot-rebuilded";
      ReplayerEvents["LoadStylesheetStart"] = "load-stylesheet-start";
      ReplayerEvents["LoadStylesheetEnd"] = "load-stylesheet-end";
      ReplayerEvents["SkipStart"] = "skip-start";
      ReplayerEvents["SkipEnd"] = "skip-end";
      ReplayerEvents["MouseInteraction"] = "mouse-interaction";
  })(ReplayerEvents || (ReplayerEvents = {}));
  //# sourceMappingURL=types.js.map

  function on(type, fn, target = document) {
      const options = { capture: true, passive: true };
      target.addEventListener(type, fn, options);
      return () => target.removeEventListener(type, fn, options);
  }
  function getWindowHeight() {
      return (window.innerHeight ||
          (document.documentElement && document.documentElement.clientHeight) ||
          (document.body && document.body.clientHeight));
  }
  function getWindowWidth() {
      return (window.innerWidth ||
          (document.documentElement && document.documentElement.clientWidth) ||
          (document.body && document.body.clientWidth));
  }
  function polyfill() {
      if ('NodeList' in window && !NodeList.prototype.forEach) {
          NodeList.prototype.forEach = Array.prototype
              .forEach;
      }
  }
  //# sourceMappingURL=utils.js.map

  var NodeType;
  (function (NodeType) {
      NodeType[NodeType["Document"] = 0] = "Document";
      NodeType[NodeType["DocumentType"] = 1] = "DocumentType";
      NodeType[NodeType["Element"] = 2] = "Element";
      NodeType[NodeType["Text"] = 3] = "Text";
      NodeType[NodeType["CDATA"] = 4] = "CDATA";
      NodeType[NodeType["Comment"] = 5] = "Comment";
  })(NodeType || (NodeType = {}));
  //# sourceMappingURL=types.js.map

  let _id = 1;
  function getId() {
      return _id++;
  }
  function getAbsoluteRef(document, attributeValue) {
      if (attributeValue.trim() === '') {
          return attributeValue;
      }
      let ancher = document.createElement('a');
      ancher.href = attributeValue;
      const href = ancher.href;
      return href;
  }
  function getAbsoluteSrcset(document, attributeValue) {
      if (attributeValue.trim() === '') {
          return attributeValue;
      }
      const srcsets = attributeValue.split(',');
      const absoluteSrcsets = srcsets.map((src) => {
          const urlAndDescriptor = src.trim().split(' ');
          const absUrl = getAbsoluteRef(document, urlAndDescriptor[0]);
          if (urlAndDescriptor.length === 1) {
              return `${absUrl}`;
          }
          else if (urlAndDescriptor.length === 2) {
              return `${absUrl} ${urlAndDescriptor[1]}`;
          }
          return '';
      }).join(',');
      return absoluteSrcsets;
  }
  function extractOrigin(url) {
      let origin;
      if (url.indexOf('//') > -1) {
          // example: "https://www.google.com/maps" => "https://www.google.com"
          origin = url
              .split('/')
              .slice(0, 3)
              .join('/');
      }
      else {
          origin = url.split('/')[0];
      }
      origin = origin.split('?')[0];
      return origin;
  }
  const URL_IN_CSS_REF = /url\((?:'([^']*)'|"([^"]*)"|([^)]*))\)/gm;
  const RELATIVE_PATH = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/;
  const DATA_URI = /^(data:)([\w\/\+\-]+);(charset=[\w-]+|base64).*,(.*)/i;
  function getAbsoluteStylesheet(cssText, href) {
      return cssText.replace(URL_IN_CSS_REF, (origin, path1, path2, path3) => {
          const filePath = path1 || path2 || path3;
          if (!filePath) {
              return origin;
          }
          if (!RELATIVE_PATH.test(filePath)) {
              return `url('${filePath}')`;
          }
          if (DATA_URI.test(filePath)) {
              return `url(${filePath})`;
          }
          if (filePath[0] === '/') {
              return `url('${extractOrigin(href) + filePath}')`;
          }
          const stack = href.split('/');
          const parts = filePath.split('/');
          stack.pop();
          for (const part of parts) {
              if (part === '.') {
                  continue;
              }
              else if (part === '.') {
                  stack.pop();
              }
              else {
                  stack.push(part);
              }
          }
          return `url('${stack.join('/')}')`;
      });
  }
  function getCSSRulesString(styleSheet) {
      try {
          const rules = styleSheet.rules || styleSheet.cssRules;
          return rules ?
              Array.from(rules).reduce((prev, cur) => prev + getCSSRuleString(cur), '') : null;
      }
      catch (error) {
          return null;
      }
  }
  function getCSSRuleString(rule) {
      return isCSSImportRule(rule) ?
          getCSSRulesString(rule.styleSheet) || ''
          : rule.cssText;
  }
  function isCSSImportRule(rule) {
      return 'styleSheet' in rule;
  }
  function isSVGElement(element) {
      return element.tagName === 'svg' || element instanceof SVGElement;
  }
  function serializeNode(node, document, blockClass, inlineStylesheet, maskAllInputs) {
      switch (node.nodeType) {
          case node.DOCUMENT_NODE:
              return {
                  type: NodeType.Document,
                  childNodes: []
              };
          case node.DOCUMENT_TYPE_NODE:
              return {
                  // Reference: https://developer.mozilla.org/en-US/docs/Web/API/DocumentType
                  type: NodeType.DocumentType,
                  name: node.name,
                  publicId: node.publicId,
                  systemId: node.systemId
              };
          case node.ELEMENT_NODE:
              let needBlock = false;
              if (typeof blockClass === 'string') {
                  needBlock = node.classList.contains(blockClass);
              }
              else {
                  node.classList.forEach((className) => {
                      if (blockClass.test(className)) {
                          needBlock = true;
                      }
                  });
              }
              const tagName = node.tagName.toLowerCase();
              const attributes = {};
              for (const { name, value } of Array.from(node.attributes)) {
                  if (name === 'src' || name === 'href') {
                      attributes[name] = getAbsoluteRef(document, value);
                  }
                  else if (name === 'srcset') {
                      attributes[name] = getAbsoluteSrcset(document, value);
                  }
                  else if (name === 'style') {
                      attributes[name] = getAbsoluteStylesheet(value, window.location.href);
                  }
                  else {
                      attributes[name] = value;
                  }
              }
              if (tagName === 'link' && inlineStylesheet) {
                  const styleSheet = Array.from(document.styleSheets).find((s) => {
                      return s.href === node.href;
                  });
                  const cssText = getCSSRulesString(styleSheet);
                  if (cssText) {
                      delete attributes.rel;
                      delete attributes.href;
                      attributes._cssText = getAbsoluteStylesheet(cssText, styleSheet.href);
                  }
              }
              if (tagName === 'style' &&
                  node.sheet &&
                  !(node.innerText ||
                      node.textContent ||
                      '').trim().length) {
                  const cssText = getCSSRulesString(node.sheet);
                  if (cssText) {
                      attributes._cssText = getAbsoluteStylesheet(cssText, location.href);
                  }
              }
              if (tagName === 'input' ||
                  tagName === 'textarea' ||
                  tagName === 'select') {
                  const value = node.value;
                  if (attributes.type !== 'radio' &&
                      attributes.type !== 'checkbox' &&
                      value) {
                      attributes.value = maskAllInputs ? '*'.repeat(value.length) : value;
                  }
                  else if (node.checked) {
                      attributes.checked = node.checked;
                  }
              }
              if (tagName === 'option') {
                  const selectValue = node.parentElement;
                  if (attributes.value === selectValue.value) {
                      attributes.selected = node.selected;
                  }
              }
              if (tagName === 'canvas') {
                  attributes.art_dataURL = node.toDataURL();
              }
              if (needBlock) {
                  const { width, height } = node.getBoundingClientRect();
                  attributes.art_width = `${width}px`;
                  attributes.art_height = `${height}px`;
              }
              return {
                  type: NodeType.Element,
                  tagName,
                  attributes,
                  childNodes: [],
                  isSVG: isSVGElement(node) || undefined,
                  needBlock
              };
          case node.TEXT_NODE:
              // The parent node may not be a element which has a tagName attribute.
              // So just let it be undefined which is ok in this use case.
              const parentTagName = node.parentNode && node.parentNode.tagName;
              let textContent = node.textContent;
              const isStyle = parentTagName === 'STYLE' ? true : undefined;
              if (isStyle && textContent) {
                  textContent = getAbsoluteStylesheet(textContent, window.location.href);
              }
              if (parentTagName === 'SCRIPT') {
                  textContent = 'SCRIPT_PLACEHOLDER';
              }
              return {
                  type: NodeType.Text,
                  textContent: textContent || '',
                  isStyle
              };
          case node.CDATA_SECTION_NODE:
              return {
                  type: NodeType.CDATA,
                  textContent: ''
              };
          case node.COMMENT_NODE:
              return {
                  type: NodeType.Comment,
                  textContent: node.textContent || ''
              };
          default:
              return false;
      }
  }
  function serializeNodeWithId(node, document, map, blockClass, skipChild = false, inlineStylesheet = true, maskAllInputs = false) {
      const serializedNode = serializeNode(node, document, blockClass, inlineStylesheet, maskAllInputs);
      if (!serializedNode) {
          return null;
      }
      let id;
      if ('__sn' in node) {
          id = node.__sn.id;
      }
      else {
          id = getId();
      }
      const serializedNodeWithId = Object.assign(serializedNode, { id });
      node.__sn = serializedNodeWithId;
      map[id] = node;
      let recordChild = !skipChild;
      if (serializedNodeWithId.type === NodeType.Element) {
          recordChild = !skipChild && !serializedNodeWithId.needBlock;
          delete serializedNodeWithId.needBlock;
      }
      if ((serializedNodeWithId.type === NodeType.Document ||
          serializedNodeWithId.type === NodeType.Element) &&
          recordChild) {
          for (const childNode of Array.from(node.childNodes)) {
              const serializedChildNode = serializeNodeWithId(childNode, document, map, blockClass, skipChild, inlineStylesheet, maskAllInputs);
              if (serializedChildNode) {
                  serializedNodeWithId.childNodes.push(serializedChildNode);
              }
          }
      }
      return serializedNodeWithId;
  }
  //# sourceMappingURL=serializeNodeWithId.js.map

  function snapshot(node, blockClass = 'art-block', inlineStylesheet = true, maskAllInputs = false) {
      const idNodeMap = {};
      return [
          serializeNodeWithId(node, node, idNodeMap, blockClass, false, inlineStylesheet, maskAllInputs),
          idNodeMap
      ];
  }
  //# sourceMappingURL=snapshot.js.map

  function wrapEvent(e) {
      return Object.assign({}, e, { timestamp: Date.now() });
  }
  let wrappedEmit;
  function record(options = {}) {
      const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = 'art-block', ignoreClass = 'art-ignore', inlineStylesheet = true, maskAllInputs = false, hooks } = options;
      // runtime checks for user options
      if (!emit) {
          throw new Error('emit function is required');
      }
      polyfill();
      let lastFullSnapshotEvent;
      let incrementalSnapshotCount = 0;
      wrappedEmit = (event, isCheckout) => {
          emit(event, isCheckout);
          if (event.type === EventType.FullSnapshot) {
              lastFullSnapshotEvent = event;
              incrementalSnapshotCount = 0;
          }
          else if (event.type === EventType.IncrementalSnapshot) {
              incrementalSnapshotCount++;
              const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
              const exceedTime = checkoutEveryNms &&
                  event.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
              if (exceedCount || exceedTime) {
                  takeFullSnapshot(true);
              }
          }
      };
      function takeFullSnapshot(isCheckout = false) {
          wrappedEmit(wrapEvent({
              type: EventType.Meta,
              data: {
                  href: window.location.href,
                  width: getWindowWidth(),
                  height: getWindowHeight()
              }
          }), isCheckout);
          const [node, idNodeMap] = snapshot(document, blockClass, inlineStylesheet, maskAllInputs);
          console.log('snapshot node: ', JSON.stringify(node));
          console.log('idNodeMap: ', idNodeMap);
          if (!node) {
              return console.warn('Failed to snapshot the document');
          }
          wrappedEmit(wrapEvent({
              type: EventType.FullSnapshot,
              data: {
                  node,
                  initialOffset: {
                      left: document.documentElement.scrollLeft,
                      top: document.documentElement.scrollTop,
                  }
              }
          }));
      }
      try {
          const handlers = [];
          handlers.push(on('DOMContentLoaded', () => {
              wrappedEmit(wrapEvent({
                  type: EventType.DomContentLoaded,
                  data: {}
              }));
          }));
          const init = () => {
              takeFullSnapshot();
              handlers.push(
              // initObservers(
              //   {
              //     mutationCb: m =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source: IncrementalSource.Mutation,
              //             ...m,
              //           },
              //         }),
              //       ),
              //     mousemoveCb: (positions, source) =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source,
              //             positions,
              //           },
              //         }),
              //       ),
              //     mouseInteractionCb: d =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source: IncrementalSource.MouseInteraction,
              //             ...d,
              //           },
              //         }),
              //       ),
              //     scrollCb: p =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source: IncrementalSource.Scroll,
              //             ...p,
              //           },
              //         }),
              //       ),
              //     viewportResizeCb: d =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source: IncrementalSource.ViewportResize,
              //             ...d,
              //           },
              //         }),
              //       ),
              //     inputCb: v =>
              //       wrappedEmit(
              //         wrapEvent({
              //           type: EventType.IncrementalSnapshot,
              //           data: {
              //             source: IncrementalSource.Input,
              //             ...v,
              //           },
              //         }),
              //       ),
              //     blockClass,
              //     ignoreClass,
              //     maskAllInputs,
              //     inlineStylesheet,
              //   },
              //   hooks
              // )
              );
          };
          if (document.readyState === 'interactive' ||
              document.readyState === 'complete') {
              init();
          }
          else {
              handlers.push(on('load', () => {
                  wrappedEmit(wrapEvent({
                      type: EventType.Load,
                      data: {},
                  }));
                  init();
              }, window));
          }
          return () => {
              // handlers.forEach(handler => handler());
          };
      }
      catch (error) {
          console.warn(error);
      }
  }
  record.addCustomEvent = (tag, payload) => {
      if (!wrappedEmit) {
          throw new Error('please add custom event after start recording');
      }
      wrappedEmit(wrapEvent({
          type: EventType.Custom,
          data: {
              tag,
              payload,
          },
      }));
  };

  record({
      emit(event) {
          console.log('recorded event: ', event);
      }
  });
  //# sourceMappingURL=index.js.map

}());
