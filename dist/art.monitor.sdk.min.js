(function () {
  'use strict';

  const COMPLETED_READY_STATE = 4;
  const NativeXHRSend = XMLHttpRequest.prototype.send;
  const requestCallbacks = [];
  const responseCallbacks = [];
  let wired = false;
  const arrayRemove = (array, item) => {
      const index = array.indexOf(item);
      if (index > -1) {
          array.splice(index, 1);
      }
      else {
          throw new Error('Could not remove ' + item + ' from array');
      }
  };
  const fireCallbacks = (callbacks, xhr) => {
      for (let i = 0, len = callbacks.length; i < len; i++) {
          callbacks[i](xhr);
      }
  };
  const fireResponseCallbacksIfCompleted = (xhr) => {
      if (xhr.readyState === COMPLETED_READY_STATE) {
          fireCallbacks(responseCallbacks, xhr);
      }
  };
  const proxifyOnReadyStateChange = (xhr) => {
      const realOnReadyStateChange = xhr.onreadystatechange;
      if (realOnReadyStateChange) {
          xhr.onreadystatechange = function () {
              fireResponseCallbacksIfCompleted(xhr);
              realOnReadyStateChange();
          };
      }
  };
  const xhrInterceptor = {
      addRequestCallback: (callback) => {
          requestCallbacks.push(callback);
      },
      removeRequestCallback: (callback) => {
          arrayRemove(requestCallbacks, callback);
      },
      addResponseCallback: (callback) => {
          responseCallbacks.push(callback);
      },
      removeResponseCallback: (callback) => {
          arrayRemove(responseCallbacks, callback);
      },
      isWired: () => {
          return wired;
      },
      wire: () => {
          // XHR interceptor already wired
          if (wired) {
              return;
          }
          // Override send method of all XHR requests
          XMLHttpRequest.prototype.send = function () {
              // Fire request callbacks before sending the request
              fireCallbacks(requestCallbacks, this);
              // Wire response callbacks
              if (this.addEventListener) {
                  const self = this;
                  this.addEventListener('readystatechange', function () {
                      fireResponseCallbacksIfCompleted(self);
                  }, false);
              }
              else {
                  proxifyOnReadyStateChange(this);
              }
              NativeXHRSend.apply(this, arguments);
          };
          wired = true;
      },
      unwire: () => {
          // XHR interceptor not currently wired
          if (!wired) {
              return;
          }
          XMLHttpRequest.prototype.send = NativeXHRSend;
          wired = false;
      }
  };
  //# sourceMappingURL=xhr-interceptor.js.map

  class LoggerBase {
      constructor(TrackType) {
          this.timestamp = performance.now();
          this.trackId = window.TRACKID;
          this.TrackType = TrackType;
      }
  }
  //# sourceMappingURL=LoggerBase.js.map

  const handleXHRResponse = (xhr) => {
      let response;
      switch (xhr.responseType) {
          case '':
          case 'text':
              response = xhr.response;
              break;
          case 'json':
              response = JSON.stringify(xhr.response);
              break;
          default:
              response = Object.prototype.toString.call(xhr.response);
              break;
      }
      return response;
  };
  class LoggerXHR extends LoggerBase {
      constructor(TrackType, xhr) {
          super(TrackType);
          this.responseURL = xhr.responseURL;
          this.status = xhr.status;
          this.statusText = xhr.statusText;
          this.responseType = xhr.responseType;
          this.response = handleXHRResponse(xhr);
          this.readyState = xhr.readyState;
          this.timeout = xhr.timeout;
      }
  }
  //# sourceMappingURL=LoggerXHR.js.map

  var TrackType;
  (function (TrackType) {
      TrackType[TrackType["EVENT"] = 0] = "EVENT";
      TrackType[TrackType["KEYBOARDEVENT"] = 1] = "KEYBOARDEVENT";
      TrackType[TrackType["MOUSEEVENT"] = 2] = "MOUSEEVENT";
      TrackType[TrackType["TOUCHEVENT"] = 3] = "TOUCHEVENT";
      TrackType[TrackType["STATECHANGE"] = 4] = "STATECHANGE";
      TrackType[TrackType["MUTATION"] = 5] = "MUTATION";
      TrackType[TrackType["XHRINTERCEPT"] = 6] = "XHRINTERCEPT";
      TrackType[TrackType["ERROR"] = 7] = "ERROR";
      TrackType[TrackType["NETWORKEVENT"] = 8] = "NETWORKEVENT";
  })(TrackType || (TrackType = {}));
  //# sourceMappingURL=TrackType.js.map

  // import { Cursor } from './Cursor';
  const promisifyRequest = (request) => {
      return new Promise((resolve, reject) => {
          request.onsuccess = () => {
              resolve(request.result);
          };
          request.onerror = () => {
              reject(request.error);
          };
      });
  };
  const promisifyRequestCall = (obj, method, args) => {
      let request;
      const promiseCall = new Promise((resolve, reject) => {
          request = obj[method].apply(obj, args);
          if (request) {
              promisifyRequest(request).then(resolve, reject);
          }
      });
      promiseCall.request = request;
      return promiseCall;
  };
  const promisifyCursorRequestCall = (obj, method, args, Cursor) => {
      const promiseCall = promisifyRequestCall(obj, method, args);
      return promiseCall.then((value) => {
          if (!value) {
              return;
          }
          return new Cursor(value, promiseCall.request);
      });
  };
  //# sourceMappingURL=promisifyRequest.js.map

  const proxyProperties = (ProxyClass, targetProp, properties) => {
      properties.forEach((prop) => {
          Object.defineProperty(ProxyClass.prototype, prop, {
              get() {
                  return this[targetProp][prop];
              },
              set(val) {
                  return this[targetProp][prop] = val;
              }
          });
      });
  };
  const proxyRequestMethods = (ProxyClass, targetProp, Constructor, properties) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return promisifyRequestCall(this[targetProp], prop, arguments);
          };
      });
  };
  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype)) {
              return;
          }
          ProxyClass.prototype[prop] = function () {
              return this[targetProp][prop].apply(this[targetProp], arguments);
          };
      });
  }
  const proxyCursorRequestMethods = (ProxyClass, targetProp, Constructor, properties, Cursor) => {
      properties.forEach((prop) => {
          if (!(prop in Constructor.prototype))
              return;
          ProxyClass.prototype[prop] = function () {
              return promisifyCursorRequestCall(this[targetProp], prop, arguments, Cursor);
          };
      });
  };
  //# sourceMappingURL=proxies.js.map

  function Cursor(cursor, request) {
      this._cursor = cursor;
      this._request = request;
  }
  proxyProperties(Cursor, '_cursor', [
      'direction',
      'key',
      'primaryKey',
      'value'
  ]);
  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [
      'update',
      'delete'
  ]);
  //# sourceMappingURL=Cursor.js.map

  function Index(index) {
      this._index = index;
  }
  proxyProperties(Index, '_index', [
      'name',
      'keyPath',
      'multiEntry',
      'unique'
  ]);
  proxyRequestMethods(Index, '_index', IDBIndex, [
      'get',
      'getKey',
      'getAll',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(Index, '_index', IDBIndex, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  //# sourceMappingURL=DBIndex.js.map

  function ObjectStore(store) {
      this._store = store;
  }
  ObjectStore.prototype.createIndex = function () {
      return new Index(this._store.createIndex.apply(this._store, arguments));
  };
  ObjectStore.prototype.index = function () {
      return new Index(this._store.index.apply(this._store, arguments));
  };
  proxyProperties(ObjectStore, '_store', [
      'name',
      'keyPath',
      'indexNames',
      'autoIncrement'
  ]);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'put',
      'add',
      'delete',
      'clear',
      'get',
      'getAll',
      'getKey',
      'getAllKeys',
      'count'
  ]);
  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'openCursor',
      'openKeyCursor'
  ], Cursor);
  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [
      'deleteIndex'
  ]);
  //# sourceMappingURL=ObjectStore.js.map

  function Transaction(idbTransaction) {
      this._tx = idbTransaction;
      this.complete = new Promise((resolve, reject) => {
          idbTransaction.oncomplete = () => {
              resolve();
          };
          idbTransaction.onerror = () => {
              reject(idbTransaction.error);
          };
          idbTransaction.onabort = () => {
              reject(idbTransaction.error);
          };
      });
  }
  Transaction.prototype.objectStore = function () {
      return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
  };
  proxyProperties(Transaction, '_tx', [
      'objectStoreNames',
      'mode'
  ]);
  proxyMethods(Transaction, '_tx', IDBTransaction, [
      'abort'
  ]);
  //# sourceMappingURL=Transaction.js.map

  function UpgradeDB(db, oldVersion, transaction) {
      this._db = db;
      this.oldVersion = oldVersion;
      this.transaction = transaction ? new Transaction(transaction) : null;
  }
  UpgradeDB.prototype.createObjectStore = function () {
      return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
  };
  proxyProperties(UpgradeDB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(UpgradeDB, '_db', IDBDatabase, [
      'deleteObjectStore',
      'close'
  ]);
  //# sourceMappingURL=UpgradeDB.js.map

  function DB(db) {
      this._db = db;
  }
  proxyProperties(DB, '_db', [
      'name',
      'version',
      'objectStoreNames'
  ]);
  proxyMethods(DB, '_db', IDBDatabase, [
      'close'
  ]);
  DB.prototype.transaction = function () {
      return new Transaction(this._db.transaction.apply(this._db, arguments));
  };
  //# sourceMappingURL=db.js.map

  function toArray(arr) {
      return Array.prototype.slice.call(arr);
  }
  ['advance', 'continue', 'continuePrimaryKey'].forEach((methodName) => {
      if (!(methodName in IDBCursor.prototype)) {
          return;
      }
      Cursor.prototype[methodName] = function () {
          const cursor = this;
          const args = arguments;
          return Promise.resolve().then(() => {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then((value) => {
                  if (!value) {
                      return;
                  }
                  return new Cursor(value, cursor._request);
              });
          });
      };
  });
  // Add cursor iterators
  ['openCursor', 'openKeyCursor'].forEach((funcName) => {
      [ObjectStore, Index].forEach((Constructor) => {
          // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
          if (!(funcName in Constructor.prototype)) {
              return;
          }
          Constructor.prototype[funcName.replace('open', 'iterate')] = function () {
              const args = toArray(arguments);
              const callback = args[args.length - 1];
              const nativeObject = this._store || this._index;
              const request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
              request.onsuccess = () => {
                  callback(request.result);
              };
          };
      });
  });
  // polyfill getAll
  [Index, ObjectStore].forEach((Constructor) => {
      if (Constructor.prototype.getAll)
          return;
      Constructor.prototype.getAll = function (query, count) {
          const instance = this;
          const items = [];
          return new Promise((resolve) => {
              instance.iterateCursor(query, (cursor) => {
                  if (!cursor) {
                      resolve(items);
                      return;
                  }
                  items.push(cursor.value);
                  if (count !== undefined && items.length === count) {
                      resolve(items);
                      return;
                  }
                  cursor.continue();
              });
          });
      };
  });
  const idb = {
      open: (name, version, upgradeCallback) => {
          const promiseWithReq = promisifyRequestCall(indexedDB, 'open', [name, version]);
          const request = promiseWithReq.request;
          if (request) {
              request.onupgradeneeded = (event) => {
                  if (upgradeCallback) {
                      upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
                  }
              };
          }
          return promiseWithReq.then((db) => {
              return new DB(db);
          });
      },
      delete: (name) => {
          return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
      }
  };
  //# sourceMappingURL=idb.js.map

  //# sourceMappingURL=index.js.map

  const DBNAME = 'QNN-MKT';
  const DBVERSION = 1;
  const OBJECTNAME = 'ERROR-REPORTING';
  const KETPATH = 'id';
  //# sourceMappingURL=DB.js.map

  class IDBStore {
      constructor(dbName, upgradeCallback) {
          this.get = (objName, key) => {
              return this.dbPromise.then((db) => {
                  return db.transaction(objName)
                      .objectStore(objName).get(key);
              });
          };
          this.set = (objName, val) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).put(val);
                  return tx.complete;
              });
          };
          this.delete = (objName, key) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).delete(key);
                  return tx.complete;
              });
          };
          this.clear = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName, 'readwrite');
                  tx.objectStore(objName).clear();
                  return tx.complete;
              });
          };
          this.getDBPromise = () => {
              return this.dbPromise;
          };
          this.keys = (objName) => {
              return this.dbPromise.then((db) => {
                  const tx = db.transaction(objName);
                  const keys = [];
                  const store = tx.objectStore(objName);
                  // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.
                  // openKeyCursor isn't supported by Safari, so we fall back
                  (store.iterateKeyCursor || store.iterateCursor).call(store, (cursor) => {
                      if (!cursor) {
                          return;
                      }
                      keys.push(cursor.key);
                      cursor.continue();
                  });
                  return tx.complete.then(() => {
                      return keys;
                  });
              });
          };
          this.dbPromise = idb.open(dbName, DBVERSION, upgradeCallback);
      }
      deleteDataBase(dbName) {
          return idb.delete(dbName)
              .then(() => {
              console.log(`delete ${dbName} database successfully`);
          })
              .catch((err) => {
              console.log(`delete ${dbName} database err: `, err);
          });
      }
  }
  const iDBStoreInstance = new IDBStore(DBNAME, (upgradeDB) => {
      if (!upgradeDB.objectStoreNames.contains(OBJECTNAME)) {
          const objectStore = upgradeDB.createObjectStore(OBJECTNAME, { keyPath: KETPATH, autoIncrement: true });
          objectStore.createIndex('timestamp', 'timestamp');
      }
  });
  //# sourceMappingURL=IDBStore.js.map

  xhrInterceptor.addResponseCallback((xhr) => {
      const xhrLogger = new LoggerXHR(TrackType.XHRINTERCEPT, xhr);
      console.log('xhr log: ', xhrLogger);
      iDBStoreInstance.set(OBJECTNAME, xhrLogger)
          .then(() => {
          console.log('xhr log added');
      })
          .catch((err) => {
          console.log('xhr log err: ', err);
      });
  });
  xhrInterceptor.wire();
  //# sourceMappingURL=xhrInterceptor.js.map

  //# sourceMappingURL=index.js.map

  /**
   * Determines whether the passed element is a DOM element
   * see: https://developer.mozilla.org/en-US/docs/Web/API/Element
   */
  const isElement = (element) => {
      let isElem;
      if (typeof Element === 'function') {
          isElem = element instanceof Element;
      }
      else {
          isElem = !!element && typeof element === 'object' &&
              element.nodeType === 1 && typeof element.nodeName === 'string';
      }
      return isElem;
  };
  //# sourceMappingURL=isElement.js.map

  const getParents = (element) => {
      const parents = [];
      let currentElement = element;
      while (isElement(currentElement)) {
          parents.push(currentElement);
          currentElement = currentElement.parentElement;
      }
      return parents;
  };
  //# sourceMappingURL=getParents.js.map

  /**
   * Return the tag name of the element
   * @param {Element} element
   */
  const getTag = (element) => {
      // Element.tagName
      return element.tagName.toLowerCase().replace(/:/g, '\\:');
  };
  //# sourceMappingURL=getTag.js.map

  /**
   * Returns the selectors based on the position of the element relative to its siblings
   * @param {Element} element
   */
  const getNthChild = (element) => {
      let counter = 0;
      const { parentElement } = element;
      if (parentElement) {
          /**
           *  NodeList and HTMLCollection both interfaces are collections of DOM nodes.
           * They differ in the methods they provide and in the type of nodes they can
           * contain. While a NodeList can contain any node type, an HTMLCollection
           * is supposed to only contain Element nodes.
           *
           * The ParentNode property children is a read-only property that returns a live
           * HTMLCollection which contains all of the child elements of the node upon which
           * it was called.
           * https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children
           */
          const { children } = parentElement;
          const len = children.length;
          for (let k = 0; k < len; k++) {
              const sibling = children[k];
              counter++;
              if (sibling === element) {
                  return `:nth-child(${counter})`;
              }
          }
      }
      return null;
  };
  //# sourceMappingURL=getNthChild.js.map

  /**
   * Returns the Attribute selectors of the element
   * @param element
   * @param attributesToIgnore
   */
  const getAttributes = (element, attributesToIgnore = ['id', 'class', 'length']) => {
      const { attributes } = element;
      if (attributes === null) {
          return null;
      }
      const acc = [];
      Array.prototype.forEach.call(attributes, (attr) => {
          if (!(attributesToIgnore.indexOf(attr.nodeName) > -1)) {
              acc.push(`[${attr.nodeName}="${attr.nodeValue}"]`);
          }
      });
      return acc.join('');
  };
  //# sourceMappingURL=getAttributes.js.map

  /**
   * Get class names for an element
   * @param element
   */
  const getClasses = (element) => {
      if (!element.hasAttribute('class')) {
          return null;
      }
      try {
          // Element.classList support from IE 10
          const classList = Array.prototype.slice.call(element.classList);
          // return only the valid CSS selectors based on RegEx
          return classList.filter((item) => {
              return /^[a-z_-][a-z\d_-]*$/i.test(item);
          }).map((className) => {
              return `.${className}`;
          }).join('');
      }
      catch (err) {
          let classNames = element.getAttribute('class');
          classNames = classNames.trim().replace(/\s+/g, ' ');
          return classNames.split(' ').map((className) => {
              return `.${className}`;
          }).join('');
      }
  };
  //# sourceMappingURL=getClasses.js.map

  /**
   * Return the id attribute of the element
   * @param {Element} element
   */
  const getID = (element) => {
      // Element.getAttribute()
      const id = element.getAttribute('id');
      if (id !== null && id !== '') {
          // if the ID starts with a number selecting with a hash will cause a DOMException
          return id.match(/^\d/) ? `[id="${id}"]` : '#' + id;
      }
      return null;
  };
  //# sourceMappingURL=getID.js.map

  /**
   * Checks if the selector is unique
   * @param element
   * @param selector
   */
  const isUnique = (element, selector) => {
      if (!selector) {
          return false;
      }
      const doc = element.ownerDocument;
      if (doc === null) {
          return false;
      }
      const elems = doc.querySelectorAll(selector);
      return elems.length === 1 && elems[0] === element;
  };
  //# sourceMappingURL=isUnique.js.map

  const getUniqueSelector = (element, attributesToIgnore) => {
      const id = getID(element);
      if (id) {
          return id;
      }
      const classes = getClasses(element);
      if (classes && isUnique(element, classes)) {
          return classes;
      }
      const attrs = getAttributes(element, attributesToIgnore);
      if (attrs && isUnique(element, attrs)) {
          return attrs;
      }
      if (classes && attrs && isUnique(element, classes + attrs)) {
          return classes + attrs;
      }
      const tag = getTag(element);
      if (isUnique(element, tag)) {
          return tag;
      }
      if (classes && attrs && isUnique(element, classes + attrs + ' ' + tag)) {
          return classes + attrs + ' ' + tag;
      }
      return null;
  };
  const unique = (element, options = {}) => {
      const { attributesToIgnore = ['id', 'class', 'length'] } = options;
      const parents = getParents(element);
      let uniqueSelector = '';
      let firstUniqueElem;
      let firstUniqueElemIndex = -1;
      for (const elem of parents) {
          const selector = getUniqueSelector(elem, attributesToIgnore);
          firstUniqueElemIndex++;
          if (selector) {
              firstUniqueElem = elem;
              uniqueSelector = selector;
              break;
          }
      }
      if (firstUniqueElem === element) {
          return uniqueSelector;
      }
      const elementPath = parents.slice(0, firstUniqueElemIndex);
      elementPath.forEach((elem) => {
          uniqueSelector = uniqueSelector + ' ' + getTag(elem) + getNthChild(elem);
      });
      return uniqueSelector;
  };
  //# sourceMappingURL=index.js.map

  const getEventTargetInfo = (eventTarget) => {
      if (eventTarget === null) {
          return null;
      }
      else if (eventTarget instanceof Element) {
          return unique(eventTarget);
      }
      else {
          return Object.prototype.toString.call(eventTarget);
      }
  };
  //# sourceMappingURL=getEventTargetInfo.js.map

  class LoggerEvent extends LoggerBase {
      constructor(TrackType, event) {
          super(TrackType);
          this.type = event.type;
          this.eventPhase = event.eventPhase;
          this.currentTarget = getEventTargetInfo(event.currentTarget);
          this.target = getEventTargetInfo(event.target);
      }
  }
  //# sourceMappingURL=LoggerEvent.js.map

  class LoggerUIEvent extends LoggerEvent {
      constructor(TrackType, uiEvent) {
          super(TrackType, uiEvent);
          const { detail } = uiEvent;
          this.detail = detail;
      }
  }
  //# sourceMappingURL=LoggerUIEvent.js.map

  class LoggerMouseEvent extends LoggerUIEvent {
      constructor(TrackType, mouseEvent) {
          super(TrackType, mouseEvent);
          this.altKey = mouseEvent.altKey;
          this.button = mouseEvent.button;
          this.buttons = mouseEvent.buttons;
          this.clientX = mouseEvent.clientX;
          this.clientY = mouseEvent.clientY;
          this.ctrlKey = mouseEvent.ctrlKey;
          this.metaKey = mouseEvent.metaKey;
          this.movementX = mouseEvent.movementX;
          this.movementY = mouseEvent.movementY;
          this.offsetX = mouseEvent.offsetX;
          this.offsetY = mouseEvent.offsetY;
          this.pageX = mouseEvent.pageX;
          this.pageY = mouseEvent.pageY;
          this.relatedTarget = getEventTargetInfo(mouseEvent.relatedTarget);
          this.screenX = mouseEvent.screenX;
          this.screenY = mouseEvent.screenY;
          this.shiftKey = mouseEvent.shiftKey;
      }
  }
  //# sourceMappingURL=LoggerMouseEvent.js.map

  const mouseEvents = ['click', 'dblclick'];
  mouseEvents.forEach((eventName) => {
      window.addEventListener(eventName, (event) => {
          const clickLog = new LoggerMouseEvent(TrackType.MOUSEEVENT, event);
          console.log('click log: ', clickLog);
          iDBStoreInstance.set(OBJECTNAME, clickLog)
              .then(() => {
              console.log('click log added');
          })
              .catch((err) => {
              console.log('click log err: ', err);
          });
      });
  });
  //# sourceMappingURL=mouseEvent.js.map

  let scrollTimeout;
  window.addEventListener('scroll', (event) => {
      if (scrollTimeout) {
          return;
      }
      const scrollLog = new LoggerEvent(TrackType.EVENT, event);
      console.log('scroll log: ', scrollLog);
      iDBStoreInstance.set(OBJECTNAME, scrollLog)
          .then(() => {
          console.log('scroll log added');
      })
          .catch((err) => {
          console.log('scroll log err: ', err);
      });
      scrollTimeout = window.setTimeout(() => {
          scrollTimeout = null;
      }, 1000);
  });
  let resizeTimeout;
  window.addEventListener('resize', (event) => {
      if (resizeTimeout) {
          return;
      }
      const resizeLog = new LoggerEvent(TrackType.EVENT, event);
      console.log('resize log: ', resizeLog);
      iDBStoreInstance.set(OBJECTNAME, resizeLog)
          .then(() => {
          console.log('resize log added');
      })
          .catch((err) => {
          console.log('resize log err: ', err);
      });
      resizeTimeout = window.setTimeout(() => {
          resizeTimeout = null;
      }, 1000);
  });
  //# sourceMappingURL=event.js.map

  class LoggerKeyboardEvent extends LoggerUIEvent {
      constructor(TrackType, keyboardEvent) {
          super(TrackType, keyboardEvent);
          this.altKey = keyboardEvent.altKey;
          this.code = keyboardEvent.code;
          this.ctrlKey = keyboardEvent.ctrlKey;
          this.key = keyboardEvent.key;
          this.location = keyboardEvent.location;
          this.metaKey = keyboardEvent.metaKey;
          this.repeat = keyboardEvent.repeat;
          this.shiftKey = keyboardEvent.shiftKey;
      }
  }
  //# sourceMappingURL=LoggerKeyboardEvent.js.map

  const mouseEvents$1 = ['keydown'];
  mouseEvents$1.forEach((eventName) => {
      window.addEventListener(eventName, (event) => {
          const keyboardLog = new LoggerKeyboardEvent(TrackType.KEYBOARDEVENT, event);
          console.log('keyboard log: ', keyboardLog);
          iDBStoreInstance.set(OBJECTNAME, keyboardLog)
              .then(() => {
              console.log('keyboard log added');
          })
              .catch((err) => {
              console.log('keyboard log err: ', err);
          });
      });
  });
  //# sourceMappingURL=keyboardEvent.js.map

  class LoggerTouchEvent extends LoggerUIEvent {
      constructor(TrackType, touchEvent) {
          super(TrackType, touchEvent);
          this.altKey = touchEvent.altKey;
          this.changedTouches = JSON.stringify(formatTouchList(touchEvent.changedTouches));
          this.ctrlKey = touchEvent.ctrlKey;
          this.metaKey = touchEvent.metaKey;
          this.shiftKey = touchEvent.shiftKey;
          this.targetTouches = JSON.stringify(formatTouchList(touchEvent.targetTouches));
          this.touches = JSON.stringify(formatTouchList(touchEvent.touches));
      }
  }
  function formatTouchList(touchList) {
      const keys = [
          'altitudeAngle', 'azimuthAngle', 'clientX', 'clientY', 'force', 'identifier', 'pageX',
          'pageY', 'radiusX', 'radiusY', 'rotationAngle', 'screenX', 'screenY', 'target'
      ];
      return Array.prototype.map.call(touchList, (touch) => {
          const forattedTouch = {};
          keys.forEach((key) => {
              if (key === 'target') {
                  forattedTouch[key] = getEventTargetInfo(touch[key]);
              }
              else {
                  forattedTouch[key] = touch[key];
              }
          });
          return forattedTouch;
      });
  }
  //# sourceMappingURL=LoggerTouchEvent.js.map

  const touchEvents = ['touchstart', 'touchend'];
  touchEvents.forEach((eventName) => {
      window.addEventListener(eventName, (event) => {
          const touchLog = new LoggerTouchEvent(TrackType.TOUCHEVENT, event);
          console.log('touchLog: ', touchLog);
          iDBStoreInstance.set(OBJECTNAME, touchLog)
              .then(() => {
              console.log('touch log added');
          })
              .catch((err) => {
              console.log('touch log err: ', err);
          });
      });
  });
  let touchmoveTimeout;
  window.addEventListener('touchmove', (event) => {
      if (touchmoveTimeout) {
          return;
      }
      const touchmoveLog = new LoggerTouchEvent(TrackType.TOUCHEVENT, event);
      console.log('touchmoveLog: ', touchmoveLog);
      iDBStoreInstance.set(OBJECTNAME, touchmoveLog)
          .then(() => {
          console.log('touch log added');
      })
          .catch((err) => {
          console.log('touch log err: ', err);
      });
      touchmoveTimeout = window.setTimeout(() => {
          touchmoveTimeout = null;
      }, 1000);
  });
  //# sourceMappingURL=touchEvent.js.map

  let supportsConstructableEventTarget;
  try {
      // tslint:disable-next-line: no-unused-expression
      new EventTarget();
      supportsConstructableEventTarget = true;
  }
  catch (err) {
      supportsConstructableEventTarget = false;
  }
  //# sourceMappingURL=support.js.map

  class EventTargetShim {
      constructor() {
          this.registry = {};
      }
      /**
       * @see https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
       */
      addEventListener(type, listener) {
          this.getRegistry(type).push(listener);
      }
      /**
       * @see https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
       */
      removeEventListener(type, listener) {
          const typeRegistery = this.getRegistry(type);
          const handlerIndex = typeRegistery.indexOf(listener);
          if (handlerIndex > -1) {
              typeRegistery.splice(handlerIndex, 1);
          }
      }
      dispatchEvent(event) {
          // Set the target then freeze the event object to prevent modification.
          event.target = this;
          Object.freeze(event);
          this.getRegistry(event.type).forEach((listener) => {
              return listener(event);
          });
          return true;
      }
      /**
       * Returns an array of handlers associated with the passed event type.
       * If no handlers have been registered, an empty array is returned.
       * @private
       */
      getRegistry(type) {
          return this.registry[type] || [];
      }
  }
  var EventTarget$1 = supportsConstructableEventTarget ? EventTarget : EventTargetShim;
  //# sourceMappingURL=EventTarget.js.map

  /**
   * A minimal Event class shim.
   * This is used if the browser doesn't natively support constructable
   * EventTarget objects.
   */
  class EventShim {
      constructor(type) {
          this.type = type;
      }
  }
  var Event$1 = supportsConstructableEventTarget ? Event : EventShim;
  //# sourceMappingURL=Event.js.map

  class StateChangeEvent extends Event$1 {
      constructor(type, initDict) {
          super(type);
          this.newState = initDict.newState;
          this.prevState = initDict.prevState;
          this.originalEvent = initDict.originalEvent;
      }
  }
  //# sourceMappingURL=StateChangeEvent.js.map

  var PageState;
  (function (PageState) {
      PageState["ACTIVE"] = "active";
      PageState["PASSIVE"] = "passive";
      PageState["HIDDEN"] = "hidden";
      PageState["FROZEN"] = "frozen";
      // 'DISCARDED' = 'discarded', Not used but show to completeness.
      PageState["TERMINATED"] = "terminated";
  })(PageState || (PageState = {}));
  //# sourceMappingURL=PageState.js.map

  var PageEvent;
  (function (PageEvent) {
      PageEvent["focus"] = "focus";
      PageEvent["blur"] = "blur";
      PageEvent["visibilitychange"] = "visibilitychange";
      PageEvent["freeze"] = "freeze";
      PageEvent["resume"] = "resume";
      PageEvent["pageshow"] = "pageshow";
      PageEvent["pagehide"] = "pagehide";
      PageEvent["unload"] = "unload";
  })(PageEvent || (PageEvent = {}));
  //# sourceMappingURL=PageEvent.js.map

  const ACTIVE = PageState.ACTIVE;
  const PASSIVE = PageState.PASSIVE;
  const HIDDEN = PageState.HIDDEN;
  const FROZEN = PageState.FROZEN;
  // const DISCARDED = PageState.DISCARDED; Not used but show to completeness.
  const TERMINATED = PageState.TERMINATED;
  // Detect Safari to work around Safari-specific bugs.
  const safari = window.safari;
  const IS_SAFARI = typeof safari === 'object' && safari.pushNotification;
  const SUPPORTS_PAGE_TRANSITION_EVENTS = 'onpageshow' in self;
  const EVENTS = [
      PageEvent.focus,
      PageEvent.blur,
      PageEvent.visibilitychange,
      PageEvent.freeze,
      PageEvent.resume,
      PageEvent.pageshow,
      // IE9-10 do not support the pagehide event, so we fall back to unload
      // Note: unload *MUST ONLY* be added conditionally, otherwise it will
      // prevent page navigation caching (a.k.a bfcache).
      SUPPORTS_PAGE_TRANSITION_EVENTS ? PageEvent.pagehide : PageEvent.unload
  ];
  const onbeforeunload = (event) => {
      event.preventDefault();
      return event.returnValue = true;
  };
  /**
   * Converts an array of states into an object where the state is the key
   * and the value is the index.
   * @param arr {string[]} arr
   */
  const toIndexedObject = (arr) => {
      return arr.reduce((acc, curr, index) => {
          acc[curr] = index;
          return acc;
      }, {});
  };
  const LEGAL_STATE_TRANSITIONS = [
      // The normal unload process (bfcache process is addressed above).
      [ACTIVE, PASSIVE, HIDDEN, TERMINATED],
      // An active page transitioning to frozen,
      // or an unloading page going into the bfcache.
      [ACTIVE, PASSIVE, HIDDEN, FROZEN],
      // A hidden page transitioning back to active.
      [HIDDEN, PASSIVE, ACTIVE],
      // A frozen page being resumed
      [FROZEN, HIDDEN],
      // A frozen (bfcached) page navigated back to
      // Note: [FROZEN, HIDDEN] can happen here, but it's already covered above.
      [FROZEN, ACTIVE],
      [FROZEN, PASSIVE]
  ].map(toIndexedObject);
  /**
   * Accepts a current state and a future state and returns an array of legal
   * state transition paths. This is needed to normalize behavior across browsers
   * since some browsers do not fire events in certain cases and thus skip
   * states.
   * @param prevState string
   * @param currState string
   */
  const getLegalStateTransitionPath = (prevState, currState) => {
      for (let i = 0, len = LEGAL_STATE_TRANSITIONS.length; i < len; ++i) {
          const order = LEGAL_STATE_TRANSITIONS[i];
          const prevIndex = order[prevState];
          const currIndex = order[currState];
          if (prevIndex >= 0 &&
              currIndex >= 0 &&
              currIndex > prevIndex) {
              // Differences greater than one should be reported
              // because it means a state was skipped.
              return Object.keys(order).slice(prevIndex, currIndex + 1);
          }
      }
      return [];
  };
  /**
   * Returns the current state based on the document's visibility and
   * in input focus states. Note this method is only used to determine
   * active vs passive vs hidden states, as other states require listening
   * for events.
   * @return {string}
   */
  const getCurrentState = () => {
      if (document.visibilityState === HIDDEN) {
          return HIDDEN;
      }
      if (document.hasFocus()) {
          return ACTIVE;
      }
      return PASSIVE;
  };
  /**
   * Class definition for the exported, singleton lifecycle instance.
   */
  class Lifecycle extends EventTarget$1 {
      /**
       * Initializes state, state history, and adds event listeners to monitor
       * state changes.
       */
      constructor() {
          super();
          this.safariBeforeUnloadTimeout = undefined;
          this.handleEvents = (event) => {
              if (IS_SAFARI) {
                  window.clearTimeout(this.safariBeforeUnloadTimeout);
              }
              switch (event.type) {
                  case 'pageshow':
                  case 'resume':
                      this.dispatchChangesIfNeeded(event, getCurrentState());
                      break;
                  case 'focus':
                      this.dispatchChangesIfNeeded(event, ACTIVE);
                      break;
                  case 'blur':
                      // The `blur` event can fire while the page is being unloaded, so we
                      // only need to update the state if the current state is "active".
                      if (this.currState === ACTIVE) {
                          this.dispatchChangesIfNeeded(event, getCurrentState());
                      }
                      break;
                  case 'pagehide':
                  case 'unload':
                      this.dispatchChangesIfNeeded(event, event.persisted ? FROZEN : TERMINATED);
                      break;
                  case 'visibilitychange':
                      // The document's `visibilityState` will change to hidden as the page
                      // is being unloaded, but in such cases the lifecycle state shouldn't
                      // change.
                      if (this.currState !== FROZEN &&
                          this.currState !== TERMINATED) {
                          this.dispatchChangesIfNeeded(event, getCurrentState());
                      }
                      break;
                  case 'freeze':
                      this.dispatchChangesIfNeeded(event, FROZEN);
                      break;
              }
          };
          const state = getCurrentState();
          this.currState = state;
          this.unsavedChanges = [];
          EVENTS.forEach((event) => {
              return window.addEventListener(event, this.handleEvents, true);
          });
          // Safari does not reliably fire the `pagehide` or `visibilitychange`
          // events when closing a tab, so we have to use `beforeunload` with a
          // timeout to check whether the default action was prevented.
          // - https://bugs.webkit.org/show_bug.cgi?id=151610
          // - https://bugs.webkit.org/show_bug.cgi?id=151234
          // NOTE: we only add this to Safari because adding it to Firefox would
          // prevent the page from being eligible for bfcache.
          if (IS_SAFARI) {
              window.addEventListener('beforeunload', (event) => {
                  this.safariBeforeUnloadTimeout = window.setTimeout(() => {
                      if (!(event.defaultPrevented || event.returnValue)) {
                          this.dispatchChangesIfNeeded(event, HIDDEN);
                      }
                  }, 0);
              });
          }
      }
      get State() {
          return this.currState;
      }
      get pageWasDiscarded() {
          return document.wasDiscarded || false;
      }
      /**
       * @param id A unique symbol or object identifying the
       * pending state. This ID is required when removing the state later.
       */
      addUnsavedChanges(id) {
          if (!(this.unsavedChanges.indexOf(id) > -1)) {
              // If this is the first state being added,
              // also add a beforeunload listener.
              if (this.unsavedChanges.length === 0) {
                  window.addEventListener('beforeunload', onbeforeunload);
              }
              this.unsavedChanges.push(id);
          }
      }
      removeUnsavedChanges(id) {
          const idIndex = this.unsavedChanges.indexOf(id);
          if (idIndex > -1) {
              this.unsavedChanges.splice(idIndex, 1);
              // If there's no more pending state, remove the event listener.
              if (this.unsavedChanges.length === 0) {
                  window.removeEventListener('beforeunload', onbeforeunload);
              }
          }
      }
      dispatchChangesIfNeeded(originalEvent, newState) {
          if (newState !== this.currState) {
              const prevState = this.currState;
              const path = getLegalStateTransitionPath(prevState, newState);
              for (let i = 0, len = path.length; i < len - 1; ++i) {
                  // tslint:disable-next-line: no-shadowed-variable
                  const prevState = path[i];
                  // tslint:disable-next-line: no-shadowed-variable
                  const newState = path[i + 1];
                  this.currState = newState;
                  this.dispatchEvent(new StateChangeEvent('statechange', {
                      prevState,
                      newState,
                      originalEvent
                  }));
              }
          }
      }
  }
  //# sourceMappingURL=Lifecycle.js.map

  var lifecycle = new Lifecycle();
  //# sourceMappingURL=index.js.map

  class LoggerStateChangeEvent extends LoggerEvent {
      constructor(TrackType, stateChangeEvent) {
          super(TrackType, stateChangeEvent);
          this.newState = stateChangeEvent.newState;
          this.prevState = stateChangeEvent.prevState;
      }
  }
  //# sourceMappingURL=LoggerStateChangeEvent.js.map

  lifecycle.addEventListener('statechange', (event) => {
      const statechangeLogger = new LoggerStateChangeEvent(TrackType.STATECHANGE, event);
      console.log('statechange log: ', statechangeLogger);
      iDBStoreInstance.set(OBJECTNAME, statechangeLogger)
          .then(() => {
          console.log('statechange log added');
      })
          .catch((err) => {
          console.log('statechange log err: ', err);
      });
      const newState = statechangeLogger.newState;
      if (newState === PageState.TERMINATED) {
          iDBStoreInstance.deleteDataBase(DBNAME);
      }
  });
  //# sourceMappingURL=statechangeEvent.js.map

  /**
   * list all standard events. Art error monitor will only listen to part of following
   * events, listing all of them just for completeness.
   */
  var Event$2;
  (function (Event) {
      Event["abort"] = "abort";
      Event["error"] = "error";
      Event["afterprint"] = "afterprint";
      Event["appinstalled"] = "appinstalled";
      Event["audioend"] = "audioend";
      Event["audiostart"] = "audiostart";
      Event["beforeprint"] = "beforeprint";
      Event["canplay"] = "canplay";
      Event["canplaythrough"] = "canplaythrough";
      Event["change"] = "change";
      Event["chargingchange"] = "chargingchange";
      Event["chargingtimechange"] = "chargingtimechange";
      Event["dischargingtimechange"] = "dischargingtimechange";
      Event["levelchange"] = "levelchange";
      Event["open"] = "open";
      Event["close"] = "close";
      Event["blocked"] = "blocked";
      Event["complete"] = "complete";
      Event["success"] = "success";
      Event["upgradeneeded"] = "upgradeneeded";
      Event["versionchange"] = "versionchange";
      Event["devicechange"] = "devicechange";
      Event["DOMContentLoaded"] = "DOMContentLoaded";
      Event["durationchange"] = "durationchange";
      Event["emptied"] = "emptied";
      Event["ended"] = "ended";
      Event["end"] = "end";
      Event["fullscreenchange"] = "fullscreenchange";
      Event["fullscreenerror"] = "fullscreenerror";
      Event["input"] = "input";
      Event["invalid"] = "invalid";
      Event["languagechange"] = "languagechange";
      Event["loadeddata"] = "loadeddata";
      Event["loadedmetadata"] = "loadedmetadata";
      Event["online"] = "online";
      Event["offline"] = "offline";
      Event["orientationchange"] = "orientationchange";
      Event["play"] = "play";
      Event["playing"] = "playing";
      Event["pause"] = "pause";
      Event["ratechange"] = "ratechange";
      Event["seeked"] = "seeked";
      Event["seeking"] = "seeking";
      Event["stalled"] = "stalled";
      Event["suspend"] = "suspend";
      Event["timeupdate"] = "timeupdate";
      Event["pointerlockchange"] = "pointerlockchange";
      Event["pointerlockerror"] = "pointerlockerror";
      Event["readystatechange"] = "readystatechange";
      Event["reset"] = "reset";
      Event["selectstart"] = "selectstart";
      Event["selectionchange"] = "selectionchange";
      Event["slotchange"] = "slotchange";
      Event["start"] = "start";
      Event["soundend"] = "soundend";
      Event["soundstart"] = "soundstart";
      Event["speechend"] = "speechend";
      Event["speechstart"] = "speechstart";
      Event["voiceschanged"] = "voiceschanged";
      Event["volumechange"] = "volumechange";
      Event["waiting"] = "waiting";
      Event["submit"] = "submit";
      Event["visibilitychange"] = "visibilitychange";
  })(Event$2 || (Event$2 = {}));
  var UIEvent;
  (function (UIEvent) {
      UIEvent["abort"] = "abort";
      UIEvent["error"] = "error";
      UIEvent["load"] = "load";
      UIEvent["unload"] = "unload";
      UIEvent["resize"] = "resize";
      UIEvent["scroll"] = "scroll";
      UIEvent["select"] = "select";
      UIEvent["DOMActivate"] = "DOMActivate";
  })(UIEvent || (UIEvent = {}));
  var ProgressEvent;
  (function (ProgressEvent) {
      ProgressEvent["abort"] = "abort";
      ProgressEvent["error"] = "error";
      ProgressEvent["load"] = "load";
      ProgressEvent["loadstart"] = "loadstart";
      ProgressEvent["loadend"] = "loadend";
      ProgressEvent["timeout"] = "timeout";
  })(ProgressEvent || (ProgressEvent = {}));
  // experimental
  var AnimationEvent;
  (function (AnimationEvent) {
      AnimationEvent["animationcancel"] = "animationcancel";
      AnimationEvent["animationend"] = "animationend";
      AnimationEvent["animationiteration"] = "animationiteration";
      AnimationEvent["animationstart"] = "animationstart";
  })(AnimationEvent || (AnimationEvent = {}));
  var BeforeUnloadEvent;
  (function (BeforeUnloadEvent) {
      BeforeUnloadEvent["beforeunload"] = "beforeunload";
  })(BeforeUnloadEvent || (BeforeUnloadEvent = {}));
  var TimeEvent;
  (function (TimeEvent) {
      TimeEvent["beginEvent"] = "beginEvent";
      TimeEvent["endEvent"] = "endEvent";
      TimeEvent["repeatEvent"] = "repeatEvent";
  })(TimeEvent || (TimeEvent = {}));
  // experimental
  var FocusEvent;
  (function (FocusEvent) {
      FocusEvent["blur"] = "blur";
      FocusEvent["focus"] = "focus";
      FocusEvent["focusin"] = "focusin";
      FocusEvent["focusout"] = "focusout";
      FocusEvent["DOMFocusIn"] = "DOMFocusIn";
      FocusEvent["DOMFocusOut"] = "DOMFocusOut";
  })(FocusEvent || (FocusEvent = {}));
  var SpeechSynthesisEvent;
  (function (SpeechSynthesisEvent) {
      SpeechSynthesisEvent["boundary"] = "boundary";
      SpeechSynthesisEvent["start"] = "start";
      SpeechSynthesisEvent["end"] = "end";
      SpeechSynthesisEvent["mark"] = "mark";
      SpeechSynthesisEvent["pause"] = "pause";
      SpeechSynthesisEvent["resume"] = "resume";
  })(SpeechSynthesisEvent || (SpeechSynthesisEvent = {}));
  var MouseEvent;
  (function (MouseEvent) {
      MouseEvent["click"] = "click";
      MouseEvent["contextmenu"] = "contextmenu";
      MouseEvent["dblclick"] = "dblclick";
      MouseEvent["mousedown"] = "mousedown";
      MouseEvent["mouseenter"] = "mouseenter";
      MouseEvent["mouseleave"] = "mouseleave";
      MouseEvent["mousemove"] = "mousemove";
      MouseEvent["mouseout"] = "mouseout";
      MouseEvent["mouseover"] = "mouseover";
      MouseEvent["mouseup"] = "mouseup";
      MouseEvent["show"] = "show";
  })(MouseEvent || (MouseEvent = {}));
  var CompositionEvent;
  (function (CompositionEvent) {
      CompositionEvent["compositionstart"] = "compositionstart";
      CompositionEvent["compositionupdate"] = "compositionupdate";
      CompositionEvent["compositionend"] = "compositionend";
  })(CompositionEvent || (CompositionEvent = {}));
  // experimental
  var ClipboardEvent;
  (function (ClipboardEvent) {
      ClipboardEvent["copy"] = "copy";
      ClipboardEvent["cut"] = "cut";
      ClipboardEvent["paste"] = "paste";
  })(ClipboardEvent || (ClipboardEvent = {}));
  // experimental
  var DeviceMotionEvent;
  (function (DeviceMotionEvent) {
      DeviceMotionEvent["devicemotion"] = "devicemotion";
      DeviceMotionEvent["deviceorientation"] = "deviceorientation";
  })(DeviceMotionEvent || (DeviceMotionEvent = {}));
  var MutationEvent;
  (function (MutationEvent) {
      MutationEvent["DOMAttrModified"] = "DOMAttrModified";
      MutationEvent["DOMCharacterDataModified"] = "DOMCharacterDataModified";
      MutationEvent["DOMNodeInserted"] = "DOMNodeInserted";
      MutationEvent["DOMNodeInsertedIntoDocument"] = "DOMNodeInsertedIntoDocument";
      MutationEvent["DOMNodeRemoved"] = "DOMNodeRemoved";
      MutationEvent["DOMNodeRemovedFromDocument"] = "DOMNodeRemovedFromDocument";
      MutationEvent["DOMSubtreeModified"] = "DOMSubtreeModified";
  })(MutationEvent || (MutationEvent = {}));
  var DragEvent;
  (function (DragEvent) {
      DragEvent["drag"] = "drag";
      DragEvent["dragend"] = "dragend";
      DragEvent["dragenter"] = "dragenter";
      DragEvent["dragleave"] = "dragleave";
      DragEvent["dragover"] = "dragover";
      DragEvent["dragstart"] = "dragstart";
      DragEvent["drop"] = "drop";
  })(DragEvent || (DragEvent = {}));
  // experimental
  var SpeechSynthesisErrorEvent;
  (function (SpeechSynthesisErrorEvent) {
      SpeechSynthesisErrorEvent["error"] = "error";
  })(SpeechSynthesisErrorEvent || (SpeechSynthesisErrorEvent = {}));
  // experimental
  var GamepadEvent;
  (function (GamepadEvent) {
      GamepadEvent["gamepadconnected"] = "gamepadconnected";
      GamepadEvent["gamepaddisconnected"] = "gamepaddisconnected";
  })(GamepadEvent || (GamepadEvent = {}));
  var PointerEvent;
  (function (PointerEvent) {
      PointerEvent["gotpointercapture"] = "gotpointercapture";
      PointerEvent["lostpointercapture"] = "lostpointercapture";
      PointerEvent["pointercancel"] = "pointercancel";
      PointerEvent["pointerdown"] = "pointerdown";
      PointerEvent["pointerenter"] = "pointerenter";
      PointerEvent["pointerleave"] = "pointerleave";
      PointerEvent["pointermove"] = "pointermove";
      PointerEvent["pointerout"] = "pointerout";
      PointerEvent["pointerover"] = "pointerover";
      PointerEvent["pointerup"] = "pointerup";
  })(PointerEvent || (PointerEvent = {}));
  var HashChangeEvent;
  (function (HashChangeEvent) {
      HashChangeEvent["hashchange"] = "hashchange";
  })(HashChangeEvent || (HashChangeEvent = {}));
  var KeyboardEvent;
  (function (KeyboardEvent) {
      KeyboardEvent["keydown"] = "keydown";
      KeyboardEvent["keypress"] = "keypress";
      KeyboardEvent["keyup"] = "keyup";
  })(KeyboardEvent || (KeyboardEvent = {}));
  var MessageEvent;
  (function (MessageEvent) {
      MessageEvent["message"] = "message";
      MessageEvent["messageerror"] = "messageerror";
  })(MessageEvent || (MessageEvent = {}));
  var ServiceWorkerMessageEventOrExtendableMessageEvent;
  (function (ServiceWorkerMessageEventOrExtendableMessageEvent) {
      ServiceWorkerMessageEventOrExtendableMessageEvent["message"] = "message"; // experimental
  })(ServiceWorkerMessageEventOrExtendableMessageEvent || (ServiceWorkerMessageEventOrExtendableMessageEvent = {}));
  // experimental
  var SpeechRecognitionEvent;
  (function (SpeechRecognitionEvent) {
      SpeechRecognitionEvent["nomatch"] = "nomatch";
      SpeechRecognitionEvent["result"] = "result";
  })(SpeechRecognitionEvent || (SpeechRecognitionEvent = {}));
  // experimental
  var NotificationEvent;
  (function (NotificationEvent) {
      NotificationEvent["notificationclick"] = "notificationclick";
  })(NotificationEvent || (NotificationEvent = {}));
  var PageTransitionEvent;
  (function (PageTransitionEvent) {
      PageTransitionEvent["pagehide"] = "pagehide";
      PageTransitionEvent["pageshow"] = "pageshow";
  })(PageTransitionEvent || (PageTransitionEvent = {}));
  var PopStateEvent;
  (function (PopStateEvent) {
      PopStateEvent["popstate"] = "popstate";
      PopStateEvent["progress"] = "progress";
  })(PopStateEvent || (PopStateEvent = {}));
  // experimental
  var PushEvent;
  (function (PushEvent) {
      PushEvent["push"] = "push";
      PushEvent["pushsubscriptionchange"] = "pushsubscriptionchange";
  })(PushEvent || (PushEvent = {}));
  var Performance;
  (function (Performance) {
      Performance["resourcetimingbufferfull"] = "resourcetimingbufferfull";
  })(Performance || (Performance = {}));
  var StorageEvent;
  (function (StorageEvent) {
      StorageEvent["storage"] = "storage";
  })(StorageEvent || (StorageEvent = {}));
  var SVGEvent;
  (function (SVGEvent) {
      SVGEvent["SVGAbort"] = "SVGAbort";
      SVGEvent["SVGError"] = "SVGError";
      SVGEvent["SVGLoad"] = "SVGLoad";
      SVGEvent["SVGResize"] = "SVGResize";
      SVGEvent["SVGScroll"] = "SVGScroll";
      SVGEvent["SVGUnload"] = "SVGUnload";
  })(SVGEvent || (SVGEvent = {}));
  var SVGZoomEvent;
  (function (SVGZoomEvent) {
      SVGZoomEvent["SVGZoom"] = "SVGZoom";
  })(SVGZoomEvent || (SVGZoomEvent = {}));
  var TouchEvent;
  (function (TouchEvent) {
      TouchEvent["touchcancel"] = "touchcancel";
      TouchEvent["touchend"] = "touchend";
      TouchEvent["touchmove"] = "touchmove";
      TouchEvent["touchstart"] = "touchstart";
  })(TouchEvent || (TouchEvent = {}));
  // experimental
  var TransitionEvent;
  (function (TransitionEvent) {
      TransitionEvent["transitionend"] = "transitionend";
  })(TransitionEvent || (TransitionEvent = {}));
  // experimental
  var UserProximityEvent;
  (function (UserProximityEvent) {
      UserProximityEvent["userproximity"] = "userproximity";
  })(UserProximityEvent || (UserProximityEvent = {}));
  var WheelEvent;
  (function (WheelEvent) {
      WheelEvent["wheel"] = "wheel";
  })(WheelEvent || (WheelEvent = {}));
  // deprecated
  // export enum AudioProcessingEvent {}
  // deprecated
  // export enum OfflineAudioCompletionEvent {
  //   'complete' = 'complete'
  // }
  // deprecated
  // export enum MutationNameEvent {
  //   'DOMAttributeNameChanged' = 'DOMAttributeNameChanged',
  //   'DOMElementNameChanged' = 'DOMElementNameChanged'
  // }

  class LoggerNetwork extends LoggerEvent {
      constructor(TrackType, event) {
          super(TrackType, event);
      }
  }
  //# sourceMappingURL=LoggerNetwork.js.map

  window.addEventListener(Event$2.online, (event) => {
      console.log('You are now connected to the network.');
      const log = new LoggerNetwork(TrackType.NETWORKEVENT, event);
      console.log('Log network event: ', log);
  });
  window.addEventListener(Event$2.offline, (event) => {
      console.log('The network connection has been lost.');
      const log = new LoggerNetwork(TrackType.NETWORKEVENT, event);
      console.log('Log network event: ', log);
  });
  //# sourceMappingURL=network.js.map

  //# sourceMappingURL=index.js.map

  // import './constants/TRACKID';
  // import './performance';
  // import './utils/idb';
  // import './data-store/intervalClear';
  // import './error-tracking/errorListener';
  // import record from './recorder/index';
  // const events: any[] = [];
  // record({
  //   emit(event) {
  //     console.log('recorded event: ', event);
  //     events.push(event);
  //   }
  // });
  //# sourceMappingURL=index.js.map

}());
